<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>#badgelife struggles</title><meta property="og:title" content="#badgelife struggles"><meta property="og:type" content="website"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/badge"></head><body><header><a href="/"><img src="/images/banner.jpg" alt="blog banner"></a></header><main><p id="date" class="date">undefined NaN, NaN</p><h1 style="margin-top: 0">#badgelife struggles</h1><nav><div id="contents"><p>Table of Contents</p></div><button id="show-toc">&#9776; Contents</button></nav><p>I had a spare <a href="https://wiki.radxa.com/RockpiS">RockPi S</a> lying around from a previous project, so I decided to use it for my prototype. It&#39;s a little single-board computer powered by a 64-bit ARM SoC, so kind of like a Raspberry Pi.</p>
<p>The first part to arrive was a little LCD screen, so I decided to try and get that working first. This turned out to be quite a painful experience that led me down a dark corridor full of footguns and bear-traps. (I&#39;m a total n00b when it comes to electronics and embedded development, so a lot of the inconvenience I encountered was really due to me blindly stumbling around out of ignorance. Please forgive me.)</p>
<p>At first, things look pretty cut and dry. The screen uses SPI, which is perfect because the RockPi has two SPI buses, so all we need to do is connect a couple things and watch everything come to life. Wait&mdash;according to the pinout there&#39;s three buses, actually. The SCLK and CS pins for SPI0 aren&#39;t labeled, though, so I guess we&#39;re gonna go with SPI1.</p>
<p>Next challenge: there are a few extra pins that are driven by GPIO. No biggie, I can just edit the GPIO numbers in the vendor code. Surely this will work. Right?</p>
<p>Things are looking pretty good so far. I decided it was time to download the code for the test program (and install a compiler while I&#39;m at it), but unfortunately, the board&#39;s WiFi is pretty abysmal. Like, 1 kB/s level of suck. I can&#39;t transfer the code from my computer, either, because I had to sacrifice the front panel ports of my PC to fit a new graphics card, meaning that I only have two functioning ports that are already occupied by my keyboard and mouse. So I decide to move everything to the living room so I can run Ethernet from the router. Barely an hour into the project and I&#39;m already on the floor, not a good sign!</p>
<p>Time to run the test program and&mdash;oops, forgot to enable spidev. Thankfully it&#39;s pretty easy, we just need to edit uEnv.txt. (The device tree overlay docs claim that the chip only has <em>one</em> SPI bus for some reason.) Reboot, aaaaand&hellip; now the kernel won&#39;t run!</p>
<p>Some research confirms my stupid mistake: I forgot to remove the uart0 overlay, which uses the same pins and thus can&#39;t be enabled at the same time. But there&#39;s a bit of a complication. As a Windows user, I can&#39;t really mount the ext3-formatted boot partition to fix my mistake. So I dig out an old spare laptop which is busy running Ubuntu Server, and of course it doesn&#39;t have a MicroSD slot, so it&#39;s time to turn the house upside down looking for an adapter.</p>
<p>Finally, I find an adapter in an old pile of cables. I spring into action, plugging it into the laptop and mounting the boot partition at record speed, and&mdash;wait a minute, read only?? Why?! I take out the MicroSD adapter, only to realize that the f***ing read lock has broken off, rendering it permanently read-only.</p>
<p><em>Sigh</em>. I can feel my inner Luddite violently protesting.</p>
<p>Remarkably, a broken read lock can be fixed by simply jamming some tinfoil into the empty slot where it once was. I can now remount the card, fix my mistakes, and finally run the damn test program.</p>
<p>Of course, the screen doesn&#39;t work. No smoke, though, and at least the backlight comes on. At this point I&#39;m not really sure what&#39;s wrong, besides the fact that data is clearly not making it to the screen. After a bit of fruitless tinkering, I bite the bullet and buy a cheap logic analyzer so I can observe what&#39;s actually going on over the SPI bus.</p>
<p>TBC...</p>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/badge">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>