<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Yet Another Bitcoin Explanation</title><meta property="og:title" content="Yet Another Bitcoin Explanation"><meta property="og:type" content="website"><meta property="og:description" content="Because why not?"><meta name="description" content="Because why not?"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/bitcoin-explained"></head><body><header><a href="/"><img src="/images/banner.png" alt="blog banner"></a></header><main><p id="date" class="date">undefined NaN, NaN</p><h1 style="margin-top: 0">Yet Another Bitcoin Explanation</h1><nav><div id="contents"><p>Table of Contents</p><a href="#the-ledger"><p>The Ledger</p></a><a href="#digital-signatures"><p>Digital Signatures</p></a><a href="#unspent-transaction-outputs"><p>Unspent Transaction Outputs</p></a><a href="#double-spending-and-consensus"><p>Double Spending and Consensus</p></a><a href="#blockchain-and-proof-of-work"><p>Blockchain and Proof of Work</p></a><a href="#difficulty-adjustment"><p>Difficulty Adjustment</p></a><a href="#references"><p>References</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p>There&#39;s a small chance you might have heard of this thing called <a href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin</a>. Well, the principles behind it are rather fascinating. Unfortunately, in the recent frenzy of hype around &quot;decentralization&quot; and (<em>retching</em>) Web3, it seems that nuanced discussion about how these decentralized systems actually work has been all but lost. So let&#39;s take a deep dive into the bowels of Bitcoin.</p>
<p>Before we begin, let&#39;s establish a baseline of how conventional payment systems work so that we can contrast it with how Bitcoin operates. The modern financial system has taken on a great deal of complexity over the ages, but a simplification will do for our purposes: a centralized organization, such as your bank, is responsible for keeping track of its clients&#39; account balances. When a transaction is made, the bank updates the balances of each party involved in the transaction. This system works very well from a functional standpoint, but such a system has two disadvantages:</p>
<ul>
<li><p>Your account is entirely controlled by whichever organization you choose to keep your money with.</p>
</li>
<li><p>All of your transactions must be tied to a real-world identity.</p>
</li>
</ul>
<p>These issues can be remedied by eliminating the central authority, but this raises an obvious problem: who keeps track of transactions, then? Bitcoin solves this by keeping a full record of all transactions (the <em>ledger</em>) on every node in the network.</p>
<h1 id="the-ledger">The Ledger <a class="section-link" href="#the-ledger">&sect;</a></h1><p>Suppose that I (Adrian) and three other friends&mdash;we&#39;ll call them Jayant, Akarsh, and Izaan&mdash;want to create a decentralized payment system. We come up with a simple scheme: whenever one of us makes a transaction, we will record it in our personal ledger and relay it to another member of the network, who will repeat this process until everyone has seen the transaction.</p>
<p>This works fine, initially; we can keep track of how much money each person has by finding the difference between how much money they&#39;ve received and how much money they&#39;ve sent. This way, transactions where a person attempts to spend more money than they actually have can be rejected. However, this scheme has some major problems.</p>
<p><strong>Transaction Authenticity</strong></p>
<p>Anyone can make a transaction as anybody else. For example, Jayant could fabricate a transaction where I send him all of my funds, and broadcast it to the network. This is obviously unacceptable, but it&#39;s actually easily solved with cryptography.</p>
<h2 id="digital-signatures">Digital Signatures <a class="section-link" href="#digital-signatures">&sect;</a></h2><figure style="max-width: 491px">
    <img src="digital-signature.png" alt="illustration of a digital signature scheme">
    <figcaption>A diagram of a public-key digital signature scheme. <a href="https://en.wikipedia.org/wiki/File:Private_key_signing.svg">Image</a> by <a href="https://commons.wikimedia.org/wiki/User:FlippyFlink">FlippyFlink</a> / <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA</a></figcaption>
</figure>

<p>Thanks to the magic of cryptography, there are schemes which allow you to produce a digital signature which anyone can verify but no one can forge. Here&#39;s how it works:</p>
<ul>
<li><p>First, the signer generates a value known as a private key. An algorithm is used to derive the corresponding public key. The keypair has the property that you cannot determine the value of the private key from the value of the public key, so it is safe to distribute the public key.</p>
</li>
<li><p>To sign a message, the signer feeds the message and the private key into a signing algorithm, which produces a fixed-length digital signature. This signature can then be distributed alongside the message to prove its authenticity.</p>
</li>
<li><p>Anyone can input the message, the signature, and the signer&#39;s public key into a verification algorithm. The verification will fail if the message has been altered or the signature is not valid.</p>
</li>
</ul>
<p>Digital signatures can help us secure our transaction system against impersonation. We can switch to using public keys instead of names instead of identities. By requiring that each transaction contain a valid signature, we make it essentially impossible for someone to create transactions as someone else.</p>
<p>However, digital signatures do not fully solve our problems. For example, if I made a transaction sending Akarsh some money, while he&#39;s unable to create a transaction using my identity since he cannot forge the signature, he can simply rebroadcast the same transaction sending him money as many times as he&#39;d like, executing a <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attack</a>. We can fix this scheme by embracing the notion of unspent transaction outputs.</p>
<h2 id="unspent-transaction-outputs">Unspent Transaction Outputs <a class="section-link" href="#unspent-transaction-outputs">&sect;</a></h2><p>So far, we&#39;ve regarded our digital currency as only existing in abstract quantities. The truth is, Bitcoin handles things a little differently.</p>
<p>In the Bitcoin protocol, each transaction is an entity with inputs and outputs. Each input references the output of a previous transaction. By mandating that a given output can only be spent once, we prevent replay attacks from succeeding. This also simplifies transaction validation, since nodes can simply maintain a list of unspent transaction outputs (<a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXOs</a>) instead of going through every single transaction in the ledger.</p>
<p>Here&#39;s an example of how UTXOs work. Suppose Akarsh sends me 10 coins. He would use one of his UTXOs as the input to the transaction, which would have an output of 10 coins to my public key and another output back to Akarsh if the value of the input was not exactly equal to 10, kind of like change in a cash transaction. If I wanted to send 7 coins to Jayant, I would create a transaction with the output of the prior transaction as the input. The new transaction would have two outputs, one addressed to Jayant worth 7 coins, and one addressed to me worth 3 coins. </p>
<figure style="max-width: 793px">
    <img src="utxo.png" alt="diagram of the previously described exchange">
    <figcaption>A visual representation of the exchange, totally not drawn in MS Paint. Note that this is a simplification; today, most transactions have multiple inputs and outputs.</figcaption>
</figure>

<p>This seemingly makes our currency watertight, but... how exactly do we keep nodes from trying to spend the same output several times? The way Bitcoin approaches this problem forms the foundation of blockchain technology. Let&#39;s dig in.</p>
<h1 id="double-spending-and-consensus">Double Spending and Consensus <a class="section-link" href="#double-spending-and-consensus">&sect;</a></h1><p>Double spending is a problem that most conventional payment systems don&#39;t have. For instance, it is physically impossible to double-spend cash; if I pay someone with a five-dollar note. I can&#39;t pay someone else with that note since I no longer have it after the transaction. But the Bitcoin network suffers from incomplete knowledge: because messages have to be relayed from node-to-node, the order which members of the network receive transactions can vary wildly. </p>
<p>This can easily be exploited in our current scheme. Suppose Jayant and Adrian both operate online businesses which accept our hypothetical cryptocurrency. Izaan could create two transactions, one to Adrian and one to Jayant, and send them both into the network at the same time. Nodes which receive his transaction to Adrian first will reject the one to Jayant, and nodes which receive his transaction to Jayant first will reject the one to Adrian. Essentially, there is disagreement about the order of transactions. Without resolving conflicts like this, the network cannot function.</p>
<p>One logical solution to this problem is to take a vote. All nodes will accept the most popular option, and the network will come to agreement about the state of the ledger. But how do we allocate these votes? A naive solution would be to assign each host (each IP address) one vote, but as explained in the Bitcoin whitepaper, this has obvious pitfalls:</p>
<blockquote>
<p>If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. </p>
</blockquote>
<p>The way Bitcoin gets around this problem is insanely clever (in my book), but it is also the #1 contributor to Bitcoin&#39;s inefficiency and high environmental impact. Here&#39;s how it works.</p>
<h1 id="blockchain-and-proof-of-work">Blockchain and Proof of Work <a class="section-link" href="#blockchain-and-proof-of-work">&sect;</a></h1><figure style="max-width: 1022px">
    <img src="blockchain.png" alt="diagram of the blockchain from the bitcoin whitepaper">
    <figcaption>The blockchain, as depicted in the Bitcoin whitepaper, in all its unadulterated glory.</figcaption>
</figure>


<p>Now is probably a good time to drop the concept of the ledger and introduce the concept of the <a href="https://en.wikipedia.org/wiki/Blockchain">blockchain</a>. The two are very similar datastructures; ultimately, both serve as linear records of transactions. However, if the entire network had to come to an agreement over every single transaction, the overhead would be tremendous (especially since <em>most</em> transactions aren&#39;t double-spend attempts, so wasting time on synchronization is pointless). Thus, we aggregate transactions into <em>blocks</em>, each of which can contain hundreds of transactions.</p>
<p>Before we can discuss how Bitcoin is secured, we must first introduce the concept of a <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a>, or just a hash. Cryptographic hashes are functions which take an input of any size and output a fixed-size hash. These functions have a couple important properties:</p>
<ul>
<li>It is very difficult to determine the input based on the output.</li>
<li>As a corollary, it is very difficult to determine which input will produce a specific output.</li>
<li>A small change in the input will result in a very significant change in the output.</li>
</ul>
<p>Bitcoin is built around the <a href="https://en.wikipedia.org/wiki/SHA-2">SHA-256</a> hash function. SHA-256 is one if not <em>the</em> most popular cryptographic hash function; it has withstood over 20 years of cryptanalysis while still remaining very secure.</p>
<p>During normal operation of the network, nodes known as <em>miners</em> continually accept incoming transactions and validate them. Then, they combine the transactions with a couple of fields to create a new block header. A block header contains the following fields:</p>
<ul>
<li>A version number</li>
<li>The hash of the previous block in the chain</li>
<li>The hash of all the transactions contained within the block</li>
<li>The time at which the block was mined</li>
<li>The target</li>
<li>The nonce</li>
</ul>
<aside>

<p>TODO: Talk about Merkle trees and why they&#39;re useful in SPV</p>
</aside>

<p>Since each header contains a reference to the previous header in the form of a cryptographic hash, the blockchain can be thought of as a singly-linked list of block headers.</p>
<p>There are two fields here whose meaning is not self-apparent: the target, and the nonce. Both have to do with the <strong>mining</strong> process, which is how new blocks are generated. Biascally, there&#39;s a 256-bit value called the <em>target</em>, which every node calculates independently based on previous blocks. The job of the miner is to adjust the nonce so that the SHA256 hash of the block header is lower than the target. The miner has no way to intelligently determine what value of the nonce will fulfill this condition; their only choice is to repeatedly hash the block, incrementing the nonce one at a time, until they&#39;ve successfully mined the block. </p>
<aside>

<p>To incentivize mining, miners are allowed to include a <strong>coinbase transaction</strong> in each block, crediting themselves with a certain amount of Bitcoin as a reward for their efforts. Coinbase transactions have non-zero outputs but no inputs, so they are how new Bitcoins are introduced into the system. </p>
<p>The maximum amount which a miner can claim from a new block is hard-coded into all nodes on the network. The reward from the first block was 50 Bitcoins; subsequently, the reward is halved every 210,000 blocks. Nodes will reject blocks where the miners try to reward themselves too much Bitcoin.</p>
</aside>

<p>What purpose does this serve? Recall the vote allocation problem from earlier. Mining is how members of the Bitcoin network cast a vote for whichever version of the blockchain they believe is correct. You can&#39;t forge a vote because it&#39;s not possible to mine a new block without doing all the work; mining is a very computationally expensive process, so an attacker would have to procure an astonishing amount of processing power to overrule legitimate miners on the network.</p>
<aside>

<p>This is where the concept of the <strong>51% attack</strong> (also known as the majority attack) arises. If an attacker can produce new blocks faster than the rest of the network, they could create an alternative chain that will be preferred by nodes on the network, giving them the ability to replace recent blocks. Thankfully, the network hashrate is high enough that such an attack is very implausible.</p>
</aside>

<p>It can be shown that proof-of-work effectively addresses the double spending problem. Consider a situation where we&#39;ve created two conflicting transactions, and broadcast them simultaneously. Each miner will accept only one of the conflicting transactions to be included in a block. Eventually, one miner will &quot;win&quot;, and other miners will forget the other transaction to work on the longest chain.</p>
<p>This is what makes Bitcoin transactions irreversible: to replace an old block, you&#39;d need to create a new blockchain with more work put into it than the primary chain. The difficulty of performing such an attack increases rapidly over time. As a result, the older the transaction is, the harder it is to reverse. As a rule of thumb, once a transaction has 6 &quot;confirmations&quot; (6 blocks mined after the one it was included in), it is considered irreversible. For low-value transactions, it&#39;s OK to accept them when they have 1 or even 0 confirmations.</p>
<h1 id="difficulty-adjustment">Difficulty Adjustment <a class="section-link" href="#difficulty-adjustment">&sect;</a></h1><p>Since the creation of Bitcoin, more and more miners have joined the network, causing the rate at which blocks are being attacked to increase tremendously. As of the writing of this article, the Bitcoin network performs around around 225 exahashes per second, which is an unimaginably large number. For reference, 225 exaseconds is equal to approximately 7 trillion years. If the target remained constant, so many blocks would be mined per second that the network would surely collapse.</p>
<p>To counteract this, Bitcoin nodes are programmed to automatically readjust the target from time to time so that blocks are produced at a steady rate. This process is known as <strong>difficulty adjustment</strong>. Difficulty adjustment is implemented as a recalculation of the target value every 2,016 blocks. The formula which Bitcoin clients use to determine the new target is tailored to produce a rate of one block every 10 minutes, on average. This can be accomplished by looking at the block time values in the headers of past blocks.</p>
<aside>

<p>Since block times are critical to determining the difficulty of the network, the Bitcoin client uses some heuristics to reject blocks with grossly manipulated timestamps:</p>
<ul>
<li>The timestamp of a new block must be greater than the median of the last 11 blocks.</li>
<li>The block cannot be more than two hours ahead of the network-adjusted time, which the node determines by looking at timestamps sent by other peers.</li>
</ul>
<p>As you can see, these rules are fairly lax, so block timestamps tend to be fairly inaccurate. There is no guarantee that they increase monotonically, and some miner pools are known to intentionally bias their timestamps for one reason or another.</p>
<p>For more info on the implementation details, check out <a href="https://github.com/bitcoin/bitcoin/blob/b25a752dfdbb12fd579e1dbef2bb95096867046b/src/chain.h#L288">chain.h</a> and <a href="https://github.com/bitcoin/bitcoin/blob/master/src/timedata.cpp">timedata.cpp</a>.</p>
</aside>

<h1 id="references">References <a class="section-link" href="#references">&sect;</a></h1><ul>
<li><a href="https://bitcoin.org/bitcoin.pdf">Satoshi Nakamoto - Bitcoin Whitepaper</a></li>
<li><a href="http://hhanh00.github.io/bitcoin-akka-tutorial/index.html">Bitcoin-Akka (full Bitcoin implementation in Scala with associated commentary)</a></li>
<li><a href="https://developer.bitcoin.org/devguide/index.html">Bitcoin.org Developer Documentation</a></li>
<li><a href="https://aantonop.com/books/mastering-bitcoin/">Andreas Antonopoulos - Mastering Bitcoin</a></li>
</ul>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>