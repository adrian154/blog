<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Reading ExFAT Volumes in Assembly</title><meta property="og:title" content="Reading ExFAT Volumes in Assembly"><meta property="og:type" content="website"><meta property="og:description" content="A new episode in my OSDev saga."><meta name="description" content="A new episode in my OSDev saga."><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><link rel="stylesheet" href="/stylesheets/packetview.css"><script defer src="/scripts/packetview.js"></script><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/exfat-asm"></head><body><header><a href="/"><img src="/images/banner.jpg" alt="blog banner"></a></header><main><p id="date" class="date">undefined NaN, NaN</p><h1 style="margin-top: 0">Reading ExFAT Volumes in Assembly</h1><nav><div id="contents"><p>Table of Contents</p><a href="#background"><p>Background</p></a><a href="#fat-basics"><p>FAT Basics</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p>About once a year, I&#39;m able to find the motivation to work on my <a href="https://github.com/adrian154/blueberry">OSDev project</a>. I&#39;ve been in need of some distraction recently, so now seems like a fitting time to try my hand at writing a bare-bones exFAT driver in assembly.</p>
<p>The ultimate goal is to launch the kernel from a file on an exFAT-formatted partition. In order to accomplish this, a few things are necessary:</p>
<ul>
<li>Locate the partition</li>
<li>Find and load the file into memory </li>
<li>Parse ELF, perform relocation, etc.</li>
</ul>
<p>Right now, I&#39;ve got the first step down. We&#39;ll be tackling the second step in today&#39;s blogpost.</p>
<h1 id="background">Background <a class="section-link" href="#background">&sect;</a></h1><p>Before we start coding, it behooves us to have a high-level understanding of how FAT filesystems work. For starters, the name gives us some clues; FAT stands for <strong>File Allocation Table</strong>. Indeed, FAT splits every volume into two parts: the file allocation table and the cluster heap.</p>
<p>The cluster heap consists of clusters, which are simply contiguous groups of sectors of a fixed size. The FAT is a series of cluster indexes, one per cluster, forming linked lists of clusters (or cluster chains). Each file is represented by a cluster chain.</p>
<p>The directory structure also lives in the cluster heap. There is a root directory from which all files and directories descend; each directory contains references to its children.</p>
<p>For simplicity, we&#39;ll make our kernel a single file in the root directory, so our work is cut out for us:</p>
<ul>
<li>Determine filesystem parameters (sectors per cluster, location of FAT and cluster heap, etc.)</li>
<li>Find root directory, determine which cluster chain represents the kernel file</li>
<li>Read FAT to determine next cluster in chain<ul>
<li>Repeat until we&#39;ve reached the end of the chain</li>
</ul>
</li>
</ul>
<h1 id="fat-basics">FAT Basics <a class="section-link" href="#fat-basics">&sect;</a></h1><p>First, let&#39;s open up the actual disk image that we&#39;ll be working with to see if we can make some sense of it.</p>
<p>The first sector of an exFAT partition is the Main Boot Sector, which mainly serves to describe the structure of the filesystem.</p>
<p><em>Note:</em> In the disk image that I&#39;m working with, the first sector of the exFAT partition is at sector 51.</p>
<div class="client packet">
<div class="segment" data-hex="eb7690" data-name="JumpBoot">

<p>JMP instruction, a relic from older FAT filesystems where the first sector of the volume was loaded and executed.</p>
</div>
<div class="segment" data-hex="4558464154202020" data-name="FileSystemName">

<p>A string identifying the filesystem (&quot;EXFAT&quot;)</p>
</div>
<div class="segment" data-hex="0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" data-name="MustBeZero" data-preview-truncate="39">

<p>53 zero bytes.</p>
</div>
<div class="segment" data-hex="0000000000000000" data-name="PartitionOffset">

<p>The media-relative offset of the partition, in sectors. Zero indicates that we should ignore this field.</p>
</div>
<div class="segment" data-hex="ac7f000000000000" data-name="VolumeLength">

<p>The length of the volume, in sectors. </p>
</div>
<div class="segment" data-hex="80000000" data-name="FatOffset">

<p>The volume-relative offset of the first FAT, in sectors. In our case, this field tells us that we need to go to sector 128 + 51 = 179 to find the FATs.</p>
</div>
<div class="segment" data-hex="20000000" data-name="FatLength">

<p>The length of each FAT, in sectors.</p>
</div>
<div class="segment" data-hex="a0000000" data-name="ClusterHeapOffset">

<p>The volume-relative offset of the cluster heap, in sectors. In our case, the first cluster is located at sector 160 + 51 = 211.</p>
</div>
<div class="segment" data-hex="e10f0000" data-name="ClusterCount">

<p>The number of clusters in the cluster heap.</p>
</div>
<div class="segment" data-hex="05000000" data-name="FirstClusterOfRootDirectory">

<p>The cluster index of the root directory, from which all other directories descend.</p>
</div>
<div class="segment" data-hex="62ffc73c" data-name="VolumeSerialNumber">

<p>A value to assist in distinguishing exFAT volumes.</p>
</div>
<div class="segment" data-hex="0001" data-name="FileSystemRevision">

<p>The version of exFAT used (1.00)</p>
</div>
<div class="segment" data-hex="0000" data-name="VolumeFlags">

<p>Bitfields describing certain properties of the volume:</p>
<ul>
<li>Bit 0: which FAT is the active one (a volume can contain up to two FATs)</li>
<li>Bit 1: whether the volume is in a consistent state</li>
<li>Bit 2: whether the media has experienced read/write failures before</li>
</ul>
</div>
<div class="segment" data-hex="09" data-name="BytesPerSectorShift">

<p>The number of bytes per sector, encoded as a bitshift. In this case, it is indicated that there are 1 &lt;&lt; 9 = 512 bytes per sector. </p>
</div>
<div class="segment" data-hex="03" data-name="SectorsPerClusterShift">

<p>The number of sectors per cluster, encoded as a bitshift. In this case, there are 1 &lt;&lt; 3 = 8 sectors per cluster.</p>
</div>
<div class="segment" data-hex="01" data-name="NumberOfFats">

<p>The number of FATs in the volume.</p>
</div>
<div class="segment" data-hex="80" data-name="DriveSelect">

<p>The drive number for use with <a href="https://en.wikipedia.org/wiki/INT_13H">INT 13h</a>.</p>
</div>
<div class="segment" data-hex="00" data-name="PercentInUse">

<p>The percentage of clusters in the cluster heap available for use. In our case, our test file is so small that not even 1% of the available space is used.</p>
</div>
<div class="segment" data-hex="00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" data-name="Unused/Reserved" data-preview-truncate="39">

<p>This space is meant to be occupied by bootcode, but we don&#39;t have any. Some of this space is reserved.</p>
</div>
<div class="segment" data-hex="55aa" data-name="BootSignature">

<p>A magic number indicating to IBM PCs that the volume is bootable. Not significant in our case since this sector is not the first sector on our disk.</p>
</div>
</div>

<p>One important thing to note is that clusters are indexed starting from 2, due to historical reasons. Thus, we should interpret the FirstClusterOfRootDirectory value of 5 as three sectors beyond the start of the cluster heap.</p>
<p>Anyways, our first order of business is to read the root directory so we can locate the kernel. If we head to the sector at <code>(FirstClusterOfRootDirectory - 2) &lt;&lt; SectorsPerClusterShift + ClusterHeapOffset + PartitionOffset</code>, we&#39;ll find the root directory, which consists of a series of directory entries.</p>
<p>The first directory entry is the volume label, whose function is self-explanatory.</p>
<div class="client packet">
<div class="segment" data-hex="83" data-name="EntryType">

<p>A bitfield indicating entry type. The way exFAT categorizes entry types is, in my opinion, a little idiosyncratic. This byte consists of three bitfields:</p>
<ul>
<li>Bit 7: whether the directory is in use</li>
<li>Bit 6: the type category (0 is critical, 1 is benign)</li>
<li>Bit 5: the type importance (0 is primary, 1 is secondary)</li>
<li>Bits 0&ndash;4: the type code, whose interpretation depends on the type category and importance.</li>
</ul>
<p>In this case, the specification says that a critical primary entry with a type code of 3 is a Volume Label directory entry.</p>
</div>
<div class="segment" data-hex="09" data-name="CharacterCount">

<p>The number of characters in the volume label. Because the size of the DirectoryEntry header is fixed, this field is limited to 11.</p>
</div>
<div class="segment" data-hex="42006c007500650062006500720072007900" data-name="VolumeLabel">

<p>The volume label (&quot;Blueberry&quot;), encoded with UTF-16LE.</p>
</div>
<div class="segment" data-hex="000000000000000000000000" data-name="Unused/Reserved">

<p>The rest of the directory entry is filled with zeroes.</p>
</div>
</div>

<p>The second directory entry provides the location of the allocation bitmap, which is used by the operating system to find unused clusters fo allocation. We won&#39;t be interacting with this since we will not be writing files.</p>
<div class="client packet">
<div class="segment" data-hex="81" data-name="EntryType">

<p>0x81 indicates an in-use critical primary entry with a type code of 1. The specification says that this entry is the Allocation Bitmap.</p>
</div>
<div class="segment" data-hex="00" data-name="BitmapFlags">

<p>The LSB of this field describes which FAT the allocation bitmap describes. The remaining bits are reserved. In this case, 0 means that it describes FAT #1.</p>
</div>
<div class="segment" data-hex="000000000000000000000000000000000000" data-name="Reserved">

<p>Reserved bytes to pad out the directory entry.</p>
</div>
<div class="segment" data-hex="02000000" data-name="FirstCluster">

<p>The first cluster of the allocation bitmap.</p>
</div>
<div class="segment" data-hex="fd01000000000000" data-name="DataLength">

<p>The number of bytes in the allocation bitmap.</p>
</div>
</div>

<p>The third directory entry describes the up-case table, which maps lowercase unicode characters to their uppercase equivalents. Most characters which do not have a clear lowercase/uppercase mapping simply map to themselves, though of course this is not the case for certain ranges like the Latin alphabet.</p>
<div class="client packet">
<div class="segment" data-hex="82" data-name="EntryType">

<p>0x81 indicates an in-use critical primary entry with a type code of 2. The specification says that this entry is the Up-case Table.</p>
</div>
<div class="segment" data-hex="000000" data-name="Reserved">

<p>I&#39;m not sure why these three bytes are reserved, but they are.</p>
</div>
<div class="segment" data-hex="0dd319e6" data-name="TableChecksum">

<p>A checksum used to ensure table integrity.</p>
</div>
<div class="segment" data-hex="000000000000000000000000" data-name="Reserved">

<p>More reserved bytes.</p>
</div>
<div class="segment" data-hex="03000000" data-name="FirstCluster">

<p>The first cluster of the up-case table.</p>
</div>
<div class="segment" data-hex="fd01000000000000" data-name="DataLength">

<p>The number of bytes in the up-case table.</p>
</div>
</div>

<p>The last directory entry is the one matching our test file.</p>
<div class="client packet">
<div class="segment" data-hex="85" data-name="EntryType">

<p>0x81 indicates an in-use critical primary entry with a type code of 5. The specification says that this entry is a File.</p>
</div>
<div class="segment" data-hex="92" data-name="SecondaryCount">

<p>The number of secondary entries that follow the file.</p>
</div>
<div class="segment" data-hex="4fa7" data-name="SetChecksum">

<p>The checksum of all directory entries within the set, excluding this field.</p>
</div>
<div class="segment" data-hex="2000" data-name="FileAttributes">

<p>A set of bitfields describing file attributes.</p>
<ul>
<li>Bit 0: MS-DOS read-only attribute</li>
<li>Bit 1: MS-DOS hidden attribute</li>
<li>Bit 2: MS-DOS system attribute</li>
<li>Bit 3: reserved</li>
<li>Bit 4: MS-DOS directory attribute</li>
<li>Bit 5: MS-DOS archive attribute</li>
</ul>
<p>There&#39;s an excellent article by Raymond Chen covering the meanings of these attributes, how they came to be, and why there&#39;s a gap between system and directory on <a href="https://devblogs.microsoft.com/oldnewthing/20180830-00/?p=99615">The Old New Thing</a>.</p>
<p>I&#39;m not sure why, but one of the reserved bits is set on this file. It could be intended behavior, a bug, a misunderstanding on my part&hellip; please comment if you know more.</p>
</div>
<div class="segment" data-hex="0000" data-name="Reserved">

<p>Two reserved bytes.</p>
</div>
<div class="segment" data-hex="b0592a55" data-name="CreateTimestamp">

<p>A timestamp describing when the file was created.</p>
<ul>
<li>Bits 0&ndash;4: second</li>
<li>Bits 5&ndash;10: minute</li>
<li>Bits 11&ndash;15: hour</li>
<li>Bits 16&ndash;20: day</li>
<li>Bits 21&ndash;24: month</li>
<li>Bits 25&ndash;31: year</li>
</ul>
</div>
<div class="segment" data-hex="b0592a55" data-name="LastModifiedTimestamp">

<p>A timestamp describing when the file was modified. Same format as CreateTimestamp.</p>
</div>
<div class="segment" data-hex="b0592a55" data-name="LastAccessedTimestamp">

<p>A timestamp describing when the file was most recently accessed. Same format as CreateTimestamp.</p>
</div>
<div class="segment" data-hex="00" data-name="Create10msIncrement">

<p>An additional field providing 10ms resolution to the create timestamp.</p>
</div>
<div class="segment" data-hex="00" data-name="LastModified10msIncrement">

<p>An additional field providing 10ms resolution to the last modified timestamp.</p>
</div>
<div class="segment" data-hex="00" data-name="CreateUtcOffset">

<p>The offset from UTC of the create timestamp. A value of 0 means this offset should be ignored.</p>
</div>
<div class="segment" data-hex="00" data-name="LastModifiedUtcOffset">

<p>The offset from UTC of the last modified timestamp. A value of 0 means this offset should be ignored.</p>
</div>
<div class="segment" data-hex="00" data-name="LastAccessedUtcOffset">

<p>The offset from UTC of the last accessed timestamp. A value of 0 means this offset should be ignored.</p>
</div>
<div class="segment" data-hex="00000000000000" data-name="Reserved">

<p>Some zero bytes to pad the entry to the required length.</p>
</div>
<div class="segment" data-hex="c0" data-name="EntryType">

<p>0xC0 indicates a critical secondary entry with a type code of 0. The specification says that this entry is the Stream Extension. </p>
</div>
</div>

<p>85
02
4fa72000
0000
b0592a55
b0592a55b0592a55
00
00</p>
<p>00
00
00
00000000000000</p>
<p>c0030008683300002c00000000000000000000000600
00002c00000000000000c10074006500730074002e007400780074000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000</p>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>