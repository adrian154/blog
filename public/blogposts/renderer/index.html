<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Coding a Renderer to Recreate a Meme</title><meta property="og:title" content="Coding a Renderer to Recreate a Meme"><meta property="og:type" content="website"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/renderer"></head><body><header><p><a id="home-link" href="/">Â« more posts</a></p><h1 id="post-title">Coding a Renderer to Recreate a Meme</h1></header><main><p>I am a big fan of 3D text reaction images. This is one of my favorites:</p>
<figure style="max-width: 400px">
    <img loading="lazy" src="original.png" alt='3D render of text that reads "GAY SEX"'>
    <figcaption>3D render of text that reads "GAY SEX" &mdash; <a href="https://twitter.com/GlitchyPSI">@GlitchyPSI</a></figcaption>
</figure>

<p>(My sense of humor might be a little broken.)</p>
<p>Anyways, I also like doing 3D graphics stuff, so I decided to recreate this meme from scratch. That means writing code to generate the model, and then creating a pathtracer to render that model using realistic lighting. Here goes!</p>
<h1 id="the-model">The Model <a class="section-link" href="#the-model">&sect;</a></h1><p>We will begin by building a 3D model of the scene. There are existing tools for generating meshes from text like <a href="https://text2stl.mestres.fr/en-us/generator">Text2STL</a>, but I opted to create my own solution so I could fine-tune the parameters to perfection.</p>
<p>Our first step is to convert each character into a list of points representing the outline. A good place to start is <a href="https://opentype.js.org/">opentype.js</a>, which takes a string and turns it into an SVG path. This frees us from decoding the font files, handling things like kerning, etc. Even <em>I</em> have limits :^)</p>
<p>Feeding &quot;GAY SEX&quot; and a copy of the Impact font file into opentype.js leaves us with a list of commands that looks like this:</p>
<pre><code class="hljs"><span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;M&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">225.078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">126.5234375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">225.078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.1953125</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.1953125</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">111.484375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">84.3359375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.5078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">77.5</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">138.1640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">129.375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">129.375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">121.7578125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">119.0234375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">76.5234375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">116.2890625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">82.3828125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">116.2890625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">106.6015625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    ...
<span class="hljs-punctuation">]</span></code></pre><p>The meaning of each command is determined by the <code>type</code> field. For Impact, we need to deal with four key commands:</p>
<ul>
<li><code>M</code>: begin a new path starting at (x, y)</li>
<li><code>L</code>: draw a straight line from the previous position to (x, y)</li>
<li><code>Q</code>: draw a B&eacute;zier curve to (x, y) with a control point at (x1, y1)</li>
<li><code>Z</code>: close the path</li>
</ul>
<p>Most of these commands are pretty trivial, except for <code>Q</code>. I didn&#39;t really know how B&eacute;zier curves worked, so I replaced them with straight lines on my initial attempt. Here&#39;s what the result looks like:</p>
<p><img loading="lazy" src="no-interpolation.png" alt="text rendered without bezier curve"></p>
<p>Not <em>terrible</em>, but it&#39;s rather jagged. Let&#39;s fix this.</p>
<p>A quadratic B&eacute;zier curve, simply put, is a way of defining a smooth curve in terms of two anchor points and a control point. They work by tracing a point on an imaginary line that spans between the lines connecting the two anchor points to the control point. Frankly, it&#39;s a rather tricky concept to put into words, so here&#39;s an interactive widget that demonstrates the principle.</p>
<p><canvas id="bezier-demo" style="width: 100%"></canvas>
<input type="range" id="bezier-t" style="width: 100%" min="0" max="100" step="1">  </p>
<p>Mathematically, a B&eacute;zier curve is a parametric function, mapping a scalar input we call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> to 2D points along a path. We can obtain the point for a given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> value by first determining the coordinates of the points defining the blue line (obtained by linearly interpolating along the lines between the anchor points and the control points), and then linearly interpolating between those two points to get the point on the curve. Here is a rather crude implementation in JavaScript:</p>
<pre><code class="hljs"><span class="hljs-comment">// linearly interpolate between points A and B for t in the range [0, 1]</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">lerp2</span> = (<span class="hljs-params">A, B, t</span>) =&gt; [
    A[<span class="hljs-number">0</span>] + (B[<span class="hljs-number">0</span>] - A[<span class="hljs-number">0</span>]) * t,
    A[<span class="hljs-number">1</span>] + (B[<span class="hljs-number">1</span>] - A[<span class="hljs-number">1</span>]) * t
];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">quadBezier</span> = (<span class="hljs-params">A0, A1, C, t</span>) =&gt; <span class="hljs-title function_">lerp2</span>(<span class="hljs-title function_">lerp2</span>(<span class="hljs-variable constant_">A0</span>, C, t), <span class="hljs-title function_">lerp2</span>(C, <span class="hljs-variable constant_">A1</span>, t), t);</code></pre><p>We can apply this to our opentype.js output by evaluating <code>quadCurve</code> at regular intervals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> for every quadratic curve in the path, which yields the following discretization:</p>
<p><img loading="lazy" src="t-param.png" alt="text rendered with naive evaluation of bezier curve"></p>
<p>The lines are smooth now, but the points are distributed unevenly. For example, look at the inner curves of the S. There are <em>way</em> too many points in those areas, much more than what&#39;s necessary to create the illusion of a smooth, continuous curve. These excess points will increase the complexity of our model and slow down our renderer. If we increase the sampling interval to bring down the number of points, we end up with too few points on the larger curve segments. </p>
<p>The problem is that the relationship between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> and the length of the curve up to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>, which we call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>, is not linear. We want our samples to be evenly distributed along <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>, so we need a function mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>. For quadratic B&eacute;zier curves, a closed-form expression for arc length <em>does</em> exist, but it&#39;s rather&hellip; unwieldy:</p>
<figure>
    <img loading="lazy" src="arclen-expression.png" alt="https://gamedev.stackexchange.com/a/6019/98873">
    <figcaption><a href="https://gamedev.stackexchange.com/a/6019/98873">@robert - Bezier curve arc length</a></figcaption>
</figure>

<p>Luckily, there&#39;s an easier way. We can approximate the arc length function by evaluating the curve at regular intervals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>, recording the total length of the segments up to that point, and inverting the function. The code looks something like this:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> tToArclen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">32</span>);
<span class="hljs-keyword">let</span> totalLen = <span class="hljs-number">0</span>, prevPoint = anchor0;
tToArclen[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; tToArclen.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> sample = <span class="hljs-title function_">quadBezier</span>(anchor0, anchor1, controlPoint, i / (tToArclen.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>));
    totalLen += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">squareDist</span>(sample, prevPoint));
    tToArclen[i] = totalLen;
    prevPoint = sample;
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">arclenToT</span> = arclen =&gt; {
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(tToArclen[i] &lt; arclen) {
        i++;
    }
    <span class="hljs-keyword">return</span> (arclen - tToArclen[i -  <span class="hljs-number">1</span>]) / ((tToArclen[i] - tToArclen[i - <span class="hljs-number">1</span>]) * (tToArclen.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)) + (i - <span class="hljs-number">1</span>) / tToArclen.<span class="hljs-property">length</span>;
};</code></pre><p>In <code>arclenToT</code>, we simply use linear interpolation to find the approximate value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> that lies at an arc length of <code>dist</code> on the curve. Armed with <code>distToT</code>, we can sample the curve at even intervals of arc length rather than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>. Here&#39;s what the output looks like after we apply this technique:</p>
<p><img loading="lazy" src="arclen-param.png" alt="&quot;GAY SEX&quot;, bezier curves evaluated with arc length parameter"></p>
<p>Much better.</p>
<p>The next step is to convert our 2D outlines into a 3D model. The preferred representation for 3D objects in computer graphics is a <em>polygon mesh</em>, which is just a thin surface defined by a collection of polygons (usually triangles). We will be storing our mesh as an array of 3D points, followed by a list of triangles whose vertices are provided as indices into the array  of points. This allows us to take advantage of the fact that the same vertex is usually shared by multiple triangles to reduce memory usage.</p>
<p>Building the side walls of our text is pretty simple. We basically extrude our outlines into 3D surfaces by copying the points, shifting them to however thick we want our text to be, then connecting them to the front points with triangles. </p>
<figure>
    <img loading="lazy" src="extruded.png" alt='gay sex in glorious 3D'>
    <figcaption>I wrote a quick <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">OBJ</a> exporter so I could preview the results in Windows' 3D viewer, but we won't be using that format in our actual renderer.</figcaption>
</figure>

<p>Now we need to fill in the front and back of our 3D text, meaning that we must <a href="https://en.wikipedia.org/wiki/Polygon_triangulation">triangulate</a> each letter. This is actually kind of tricky, especially since some letters like A have holes in them. Thankfully, I came across a <a href="https://alienryderflex.com/polygon_triangulation_with_hole.shtml">blogpost</a> by Darel Rex Finley that outlined a robust algorithm in a very understandable manner. If you are working on the same problem I cannot recommend his blogpost enough, but here&#39;s the gist of it:</p>
<p>In order to triangulate a polygon, we crawl around the edge looking for a suitable triangle. When one is found, we remove it from the working set of points and start over until all the points are accounted for. This is known as the <a href="https://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method">ear-clipping method</a>.</p>
<p>{TODO:GIF}</p>
<p>How do we deal with holes? Well, it turns out that as long as the path is not self-intersecting, it&#39;s totally fine if there are some shared sides. Of course, due to the limitations of floating-point arithmetic, some fine tuning is necessary to get things working. Watch it at work:</p>
<p>{TODO:GIF}</p>
<p>Once we&#39;ve triangulated the front faces of the text, all that remains is for us to combine everything into one model and export it. This leaves us with the product of our efforts so far:</p>
<p><img loading="lazy" src="final-mesh.png" alt="final exported mesh of GAY SEX"></p>
<p>Beautiful.</p>
<h1 id="the-renderer">The Renderer <a class="section-link" href="#the-renderer">&sect;</a></h1><p>Now that we h</p>
<script src="bezier.js"></script><img id="img-view" style="display: none"></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/renderer">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>