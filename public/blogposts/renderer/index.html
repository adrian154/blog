<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Coding a Renderer to Recreate a Meme</title><meta property="og:title" content="Coding a Renderer to Recreate a Meme"><meta property="og:type" content="website"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/renderer"></head><body><header><p><a id="home-link" href="/">Â« more posts</a></p><h1 id="post-title">Coding a Renderer to Recreate a Meme</h1></header><main><p>I am a big fan of 3D text reaction images. This is one of my favorites:</p>
<figure style="max-width: 400px">
    <img loading="lazy" src="original.png" alt='3D render of text that reads "GAY SEX"'>
    <figcaption>3D render of text that reads "GAY SEX" &mdash; <a href="https://twitter.com/GlitchyPSI">@GlitchyPSI</a></figcaption>
</figure>

<p>My sense of humor might be a little broken.</p>
<p>Anyways, I also like doing 3D graphics stuff, so I decided to recreate this meme from scratch. That means writing code to generate the model, and then creating a pathtracer to render that model using realistic lighting. Let&#39;s see how I did it. </p>
<h1 id="the-model">The Model <a class="section-link" href="#the-model">&sect;</a></h1><p>We will begin by building a 3D model of the scene. There are existing tools for generating meshes from text like <a href="https://text2stl.mestres.fr/en-us/generator">Text2STL</a>, but I opted to create my own solution so I could fine-tune the parameters.</p>
<p>Right now, our goal is to convert each character into a list of points representing the outline. A good place to start is <a href="https://opentype.js.org/">opentype.js</a>, which takes a string and turns it into an SVG path. This frees us from decoding the font files, handling things like kerning, etc. Even <em>I</em> have limits :^)</p>
<p>Feeding &quot;GAY SEX&quot; and a copy of the Impact font file into opentype.js leaves us with a list of commands that looks like this:</p>
<pre><code class="hljs"><span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;M&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">225.078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">126.5234375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">225.078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.1953125</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.1953125</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">111.484375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">142.8515625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">84.3359375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">140.5078125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">77.5</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">138.1640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">129.375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;L&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">129.375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">121.7578125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">70.6640625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">119.0234375</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">76.5234375</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">116.2890625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">82.3828125</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">116.2890625</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;y&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">106.6015625</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    ...
<span class="hljs-punctuation">]</span></code></pre><p>The meaning of each command is determined by the <code>type</code> field. For Impact, we need to deal with four key commands:</p>
<ul>
<li><code>M</code>: begin a new path starting at (x, y)</li>
<li><code>L</code>: draw a straight line from the previous position to (x, y)</li>
<li><code>Q</code>: draw a B&eacute;zier curve to (x, y) with a control point at (x1, y1)</li>
<li><code>Z</code>: close the path</li>
</ul>
<p>Most of these commands are pretty trivial, except for <code>Q</code>. I didn&#39;t really know how B&eacute;zier curves worked, so I replaced them with straight lines on my initial attempt. Here&#39;s what the result looks like:</p>
<p><img loading="lazy" src="no-interpolation.png" alt="text rendered without bezier curve"></p>
<p>Not <em>terrible</em>, but it&#39;s rather jagged. Let&#39;s fix this.</p>
<p>A B&eacute;zier curve, simply put, is a way of defining a smooth curve using a control point in addition to a starting and ending point. Impact uses quadratic B&eacute;zier curves, which are created by tracing a point on an imaginary line that spans between the lines connecting the two anchor points to the control point. Frankly, it&#39;s a rather tricky concept to put into words, so here&#39;s a widget demonstrating the concept that you can interact with.</p>
<p><canvas id="bezier-demo" style="width: 100%"></canvas>
<input type="range" id="bezier-t" style="width: 100%" min="0" max="100" step="1">  </p>
<p>Mathematically, a B&eacute;zier curve is a parametric function, mapping a scalar input we call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> to 2D points along a path. We can obtain the point for a given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> value by first determining the coordinates of the points defining the blue line (obtained by linearly interpolating along the lines between the anchor points and the control points), and then linearly interpolating between those two points to get the point on the curve. Here is a rather crude implementation in JavaScript:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> <span class="hljs-title function_">lerp</span> = (<span class="hljs-params">x1, x2, t</span>) =&gt; x1 + (x2 - x1) * t;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">quadCurve</span> = (<span class="hljs-params">x0, y0, cx, cy, x1, y1, t</span>) =&gt; [
    <span class="hljs-title function_">lerp</span>(<span class="hljs-title function_">lerp</span>(x0, cx, t), <span class="hljs-title function_">lerp</span>(cx, x1, t), t),
    <span class="hljs-title function_">lerp</span>(<span class="hljs-title function_">lerp</span>(y0, cy, t), <span class="hljs-title function_">lerp</span>(cy, y1, t), t)
];</code></pre><p>We can apply this to our opentype.js output by evaluating <code>quadCurve</code> at regular intervals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> for every quadratic curve in the path, which yields the following discretization:</p>
<p><img loading="lazy" src="t-param.png" alt="text rendered with naive evaluation of bezier curve"></p>
<p>The lines are smooth now, but the points are distributed unevenly. For example, look at the inner curves of the S. There are <em>way</em> too many points in those areas, much more than what&#39;s necessary to create the illusion of a smooth, continuous curve. These excess points will increase the complexity of our model and slow down our renderer. We can try reducing the amount of times we sample the curve for each segment, but this ends up leaving the larger curve segments with a jagged appearance.</p>
<p>Ideally, we want to sample each curve at a regular interval <em>with respect to arc length</em>. To accomplish this, we need some function that maps distance traveled along the curve to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>-values.</p>
<p>For quadratic B&eacute;zier curves, a closed-form expression for arc length <em>does</em> exist, but it&#39;s rather&hellip; unwieldy:</p>
<figure>
    <img loading="lazy" src="arclen-expression.png" alt="https://gamedev.stackexchange.com/a/6019/98873">
    <figcaption><a href="https://gamedev.stackexchange.com/a/6019/98873">@robert - Bezier curve arc length</a></figcaption>
</figure>

<p>Luckily, there&#39;s an easier way. We can approximate the arc length function by evaluating the curve at regular intervals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>, recording the total length of the segments up to that point, and inverting the function. The code looks something like this:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> tToDist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">32</span>);
<span class="hljs-keyword">let</span> totLen = <span class="hljs-number">0</span>, prevPointX = <span class="hljs-literal">null</span>, prevPointY = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tToDist.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> [x, y] = <span class="hljs-title function_">quadCurve</span>(lastX, lastY, command.<span class="hljs-property">x1</span>, command.<span class="hljs-property">y1</span>, command.<span class="hljs-property">x</span>, command.<span class="hljs-property">y</span>, i / tToDist.<span class="hljs-property">length</span>)
    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) {
        tToDist[i] = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
        totLen += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>((x-prevPointX)**<span class="hljs-number">2</span> + (y-prevPointY)**<span class="hljs-number">2</span>);
        tToDist[i] = totLen;
    }
    prevPointX = x;
    prevPointY = y;
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">distToT</span> = dist =&gt; {
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">while</span>(tToDist[i] &lt; dist) {
        i++;
    }
    <span class="hljs-keyword">return</span> (dist - tToDist[i - <span class="hljs-number">1</span>]) / ((tToDist[i] - tToDist[i - <span class="hljs-number">1</span>]) * tToDist.<span class="hljs-property">length</span>) + (i - <span class="hljs-number">1</span>) / tToDist.<span class="hljs-property">length</span>;
};</code></pre><p>In <code>distToT</code>, we simply use linear interpolation to find the approximate value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> that lies at an arc length of <code>dist</code> on the curve. Armed with <code>distToT</code>, we can sample the curve at even intervals of arc length rather than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>. This simple scheme yields pretty good results:</p>
<p><img loading="lazy" src="arclen-param.png" alt="&quot;GAY SEX&quot;, bezier curves evaluated with arc length parameter"></p>
<p>Much better.</p>
<p>Now, all that&#39;s left is for us to convert our 2D outlines into a 3D model. The preferred representation for 3D objects in computer graphics is a <em>polygon mesh</em>, which is just a thin surface defined by a collection of polygons (usually triangles). We will be storing our mesh as an array of 3D points, followed by a list of triangles whose vertices are provided as indices into the array  of points. This allows us to take advantage of the fact that the same vertex is usually shared by multiple triangles to reduce memory usage.</p>
<p>Building the side walls of our text is pretty simple. We basically extrude our outlines into 3D surfaces by copying the points, shifting them to however thick we want our text to be, then connecting them to the front points with triangles. </p>
<figure>
    <img loading="lazy" src="extruded.png" alt='gay sex in glorious 3D'>
    <figcaption>GAY SEX, now in glorious 3D. I wrote a quick <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">OBJ</a> exporter so I could view the results in Windows' 3D viewer, but we won't be using that format in our actual renderer.</figcaption>
</figure>

<p>Now, we just need to fill in the front and back of our 3D text, meaning that we must <a href="https://en.wikipedia.org/wiki/Polygon_triangulation">triangulate</a> each letter. This is actually kind of tricky, especially when the letters have holes in them. Let&#39;s start by identifying which paths are holes, and which paths they are cutting holes in. Our text only has one hole (in the &quot;A&quot;), but I chose to implement a general solution in order to accomodate other strings.</p>
<script src="bezier.js"></script><img id="img-view" style="display: none"><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/renderer">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>