<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IP over Audio Jack</title><meta property="og:title" content="IP over Audio Jack"><meta property="og:type" content="website"><meta property="og:description" content="Browsing the Internet at a blazing 11 kbit/s"><meta name="description" content="Browsing the Internet at a blazing 11 kbit/s"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/ip-over-audio-jack"></head><body><header><p><a id="home-link" href="/">Â« more posts</a></p><h1 id="post-title">IP over Audio Jack</h1></header><main><p>A couple months ago, I wrote a <a href="../internet-explained/">blogpost</a> giving a basic overview of the technologies behind the Internet, starting from the physical layer. In that post, I briefly touched on the challenges faced by WiFi transceivers&mdash;specifically, coordinating transmissions between devices to ensure that only one device is transmitting on the channel at a time. I likened the problem to what happens when multiple people try to have a conversation in the same room, which got me thinking: what if we did just that? What if I wrote a program that allowed two computers to communicate through their speaker and microphone?</p>
<p>It turns out that transmitting digital data over an analog channel designed for audio is hardly a novel idea. Older readers may recall that once upon a time, the most prevalent manner of accessing the Internet was through dialup, where two modems communicate through the telephone system.</p>
<p>Speaking of which, what even is a modem? Well, <em>modem</em> is actually an abbreviation for <em>modulator-demodulator</em>. Essentially, what we are going to be doing is implementing a modem in software.</p>
<p>Before I even started the project, I decided to narrow down the scope to just devices directly connected with an audio cable. Trying to communicate via speaker and microphone introduced too many challenges that I wasn&#39;t really prepared to deal with. Oh well, maybe another day&hellip;</p>
<p>Before we start, let&#39;s establish what the hardware we are dealing with is capable of. Most sound cards are capable of sampling at 96,000 Hz, meaning that the computer measures the level of the analog signal coming from the microphone 96,000 times per second and <em>quantizes</em> the voltage on the line as a digital value. </p>
<p>For comparison, the boring old phone system samples at 8,000 Hz. Despite this insanely low bandwidth, dialup systems were still able to achieve data rates of 33.6 kbit/s, giving us around 4.2 bits/Hz. (ISPs later achieved 56K by directly interfacing with the underlying telephone system, which had gone digital by then, so it doesn&#39;t count.)</p>
<p>My goal for this project is to at least beat dialup. It <em>seems</em> like it should be easy; after all, our bandwidth is nearly 12 times greater, and since the two devices are mere feet away the noise and crosstalk should be minimal. Let&#39;s see if we can do it.</p>
<h1 id="modulation">Modulation <a class="section-link" href="#modulation">&sect;</a></h1><p>The fundamental problem we are dealing with is how to convert a digital signal to an analog one in a way that allows us to reliably recover the digital signal even in the presence of noise and latency. Thankfully, smarter people than me have already put a great deal of effort into attacking this problem, so I have literally centuries of telephony to build off of.</p>
<p>My first successful transfer between two computers was done using a simple polar return-to-zero line code. Basically, for each bit, the signal level is set to +1 or -1 depending on the bit&#39;s value. Between each bit, the line level returns to zero. This made the decoder extremely simple:</p>
<pre><code class="hljs"><span class="hljs-comment">// encoder states</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HIGH</span> = <span class="hljs-number">0</span>, <span class="hljs-variable constant_">LOW</span> = <span class="hljs-number">1</span>, <span class="hljs-variable constant_">ZERO</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">// decoded bits</span>
<span class="hljs-keyword">const</span> bits = [];

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> sample <span class="hljs-keyword">of</span> samples) {
    <span class="hljs-keyword">if</span>(sample &gt; <span class="hljs-variable constant_">THRESHOLD</span>) {
        state = <span class="hljs-variable constant_">HIGH</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sample &lt; -<span class="hljs-variable constant_">THRESHOLD</span>) {
        state = <span class="hljs-variable constant_">LOW</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span>(state != <span class="hljs-variable constant_">ZERO</span>) {
            bits.<span class="hljs-title function_">push</span>(state == <span class="hljs-variable constant_">HIGH</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        }
        state = <span class="hljs-variable constant_">ZERO</span>;
    }
}</code></pre><p>With this, we were able to transmit our first messages:</p>
<p><img loading="lazy" src="first-transmission.png" alt="first transmission; the second half is garbled due to an inserted bit"></p>
<p>After slightly tuning the value of <code>THRESHOLD</code>, we managed to transfer the full script of <em>Bee Movie</em> (2007) at the stunning rate of 11 kilobits per second. Here&#39;s what a GIF transmitted with this encoding sounds like:</p>
<figure>
    <figcaption>Try decoding the signal for a surprise!</figcaption>
    <audio controls src="gif.wav"></audio>
</figure>

<p>This success was very encouraging, but it only marked the beginning of our journey. To achieve higher bitrates, we needed to employ a better modulation scheme.</p>
<p>TBC</p>
<img id="img-view" style="display: none"><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/ip-over-audio-jack">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>