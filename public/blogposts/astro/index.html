<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>The Science of Processing Astrophotos</title><meta property="og:title" content="The Science of Processing Astrophotos"><meta property="og:type" content="website"><meta property="og:description" content="Dipping our toes in the theory behind pretty space pictures"><meta name="description" content="Dipping our toes in the theory behind pretty space pictures"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><link rel="preconnect" href="https://rsms.me/"><link rel="stylesheet" href="https://rsms.me/inter/inter.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/astro"></head><body><header><h1 id="post-title">The Science of Processing Astrophotos</h1></header><main><p>As an amateur astrophotographer, my favorite class of targets is the deep-sky objects&mdash;nebulae, galaxies, pretty much anything outside of the Solar System. Their stunning range of colors and structures make them some of the most beautiful parts of the cosmos. However, their unique characteristics make taking good photos of them a significant challenge.</p>
<p>The requirement for long exposure time brings us to our first major obstacle: the position of objects in the sky constantly changes due to Earth&#39;s rotation. If we don&#39;t account for this motion, our images of the target will appear hopelessly smeared due to motion blur. The solution is to rotate our imaging setup along the polar axis in the opposite direction of Earth&#39;s rotation, which can be accomplished with the help of an <a href="https://en.wikipedia.org/wiki/Equatorial_mount">equatorial mount</a>. This will make the sky appear stationary to the camera. </p>
<p>An equatorial mount almost completely eliminates trailing, but due to unavoidable deviations in the mount&#39;s alignment, some amount of drifting will always be present. As we push our exposure length longer and longer, these errors will show up as trailing, turning stars into elongated blobs and ruining the fine details of our target. This sets an upper limit on the exposure time of an individual frame. To overcome this limitation, we can combine (&quot;stack&quot;) multiple exposures into a final image. Stacking multiple exposures also allows us to detect and exclude defects like cosmic ray hits and satellite trails from the final image.</p>
<p>Today, we will be writing code to perform calibration and stacking. Come along, as we dive deep into the gory details of astrophoto processing. </p>
<h1 id="housekeeping">Housekeeping <a class="section-link" href="#housekeeping">&sect;</a></h1><p>Before we can get to the cool sciencey stuff, there are a few things we need to take care of. For starters, my camera (a Nikon D7000) performs some adjustments on the raw data before saving it. These adjustments can interfere with the calibration process, so I flashed a <a href="https://simeonpilgrim.com/nikon-patch/nikon-patch.html">patched firmware</a> to disable them. Do this at your own risk; you could brick your camera if you&#39;re not careful!</p>
<p>Once we&#39;ve collected our data, we need to convert it from the camera&#39;s proprietary raw format to something that our code can actually digest. The easiest solution is to use <a href="https://www.dechifro.org/dcraw/">dcraw</a>, an open-source raw decoder. dcraw outputs <a href="https://en.wikipedia.org/wiki/Netpbm">PGMs</a>, an uncompressed image format that is trivial to read. </p>
<p>Normally, dcraw applies quite a few adjustments to transform the raw files into normal-looking images. We want to keep the data as untouched as possible, so we include a few flags to minimize processing:</p>
<pre><code class="hljs">dcraw -4 -D image.NEF</code></pre><ul>
<li><code>-4</code>: output linear 16-bit values</li>
<li><code>-D</code>: output a grayscale image; do not perform any interpolation such as <a href="https://en.wikipedia.org/wiki/Demosaicing">demosaicing</a></li>
</ul>
<h1 id="all-about-sensors">All About Sensors <a class="section-link" href="#all-about-sensors">&sect;</a></h1><p><img loading="lazy" src="ccd-vs-cmos.jpg" alt="comparison of ccd and cmos sensors"></p>
<p>Modern cameras use either CCD or CMOS sensors to detect light and produce a digital readout. While these technologies have many important differences, they function on similar principles: photosites (pixels) in the sensor are struck by photons, some of which end up producing electrons. These electrons accumulate within the photosites over the span of the exposure. At the end, the charges are converted to a voltage and then digitized by an <strong>analog-to-digital converter (ADC)</strong>. The amount of amplification applied is known as the <strong>gain</strong>, which is determined by the ISO setting.</p>
<p>Our images primarily suffer from three sources of noise: dark noise, read noise, and shot noise. Let&#39;s look at the processes behind these noise sources in depth, so we can effectively mitigate them.</p>
<h2 id="shot-noise">Shot Noise <a class="section-link" href="#shot-noise">&sect;</a></h2><p>At the turn of the century, it became apparent to physicists that light is an undeniably quantum phenomenon&mdash;that is, light is not radiated continuously. Rather, it consists of discrete packets of energy that we call <em>photons</em>. Photons arrive at a constant mean rate, but because the photons are emitted at random times, the exact number of particles observed over a finite time interval will vary. We call this random variation <strong>shot noise</strong>. </p>
<p>Check out this demo, which simulates randomly emitted particles falling onto an ideal detector. Try playing around with the exposure time, and see how it affects the signal-to-noise ratio (SNR).</p>
<div style="display: block; margin: auto; width: 600px;">
<canvas id="shot-noise-demo" style="border: 1px solid #ccc;" width="600" height="300"></canvas><br>
<label for="exposure-time">Exposure time: </label><input type="range" min="0.5" max="4" step="0.5" value="1" id="exposure-time"><span id="exposure-time-text">
</div>

<script src="shot-noise.js"></script>

<p>Statistically inclined readers might recognize that photon emission is a Poisson process, because events occur independently and at a fixed mean rate. Thus, the number of events observed over a fixed time interval is given by the <a href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson distribution</a>. When the rate of events <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> is large, the Poisson distribution is closely approximated by a normal distribution with paramters <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\mu = \lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\sigma^2 = \lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>. Thus, we can say that the variance of the number of photons is equal to the average number of photons. </p>
<aside>

<p>If we define signal-to-noise ratio as mean over standard deviation, this relation also explains why we need to quadruple our exposure time to double SNR (or halve the noise).</p>
</aside>

<p>Of course, our RAW files don&#39;t tell us how many electrons were produced within the pixels. Instead, they contain arbitrary integer quantities representing the output of the ADC. It doesn&#39;t make sense to assign a physical unit to these values, so for the sake of clarity we measure these values in <strong>analog-to-digital units (ADUs)</strong>. There is some factor giving the number of ADUs per electron, which we call <strong>gain</strong>.</p>
<p>The signal statistics in ADU and electrons are related by:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mtext>ADU</mtext></msub><mo>=</mo><msub><mi>μ</mi><msup><mi mathvariant="normal">e</mi><mo>−</mo></msup></msub><mo>×</mo><mrow><mi mathvariant="normal">g</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow><annotation encoding="application/x-tex">\mu_\text{ADU} = \mu_\mathrm{e^-} \times \mathrm{gain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ADU</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">gain</span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>σ</mi><mtext>ADU</mtext></msub><mo>=</mo><msub><mi>σ</mi><msup><mi mathvariant="normal">e</mi><mo>−</mo></msup></msub><mo>×</mo><mrow><mi mathvariant="normal">g</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow><annotation encoding="application/x-tex">\sigma_\text{ADU} = \sigma_\mathrm{e^-} \times \mathrm{gain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ADU</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">gain</span></span></span></span></span></span></p>
<p>We know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><msup><mi mathvariant="normal">e</mi><mo>−</mo></msup></msub><mo>=</mo><msqrt><msub><mi>μ</mi><msup><mi mathvariant="normal">e</mi><mo>−</mo></msup></msub></msqrt></mrow><annotation encoding="application/x-tex">\sigma_\mathrm{e^-} = \sqrt{\mu_\mathrm{e^-}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.3369em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7031em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.6631em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3369em;"><span></span></span></span></span></span></span></span></span> due to shot noise, allowing us to solve for gain:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">g</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo>=</mo><mfrac><msubsup><mi>σ</mi><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">U</mi></mrow><mn>2</mn></msubsup><msub><mi>μ</mi><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">U</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{gain} = \frac{\sigma^2_\mathrm{ADU}}{\mu_\mathrm{ADU}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">gain</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3715em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">ADU</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">ADU</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Using this method, we can calculate the sensor gain for various ISO values. We see that there is a strong linear relationship.</p>
<p><img loading="lazy" src="iso-to-gain.png" alt="iso to gain scatterplot"></p>
<p>We&#39;ll use these gain measurements later when measuring other sensor properties.</p>
<h2 id="dark-noise">Dark Noise <a class="section-link" href="#dark-noise">&sect;</a></h2><p>Even in the absence of light, the photosites within a sensor will still produce some electrons due to thermal effects. This unwanted signal is known as <strong>dark current</strong>. Different pixels produce dark current at different rates, a phenomenon called <strong>dark current non-uniformity (DCNU)</strong>. Electrons are discrete, so dark current is also subject to random variation due to shot noise.</p>
<figure style="max-width: 500px">
    <!--<img loading="lazy" src="" alt="">-->
    <figcaption>Shot noise in the dark current is approximately normally distributed, as expected.</figcaption>
</figure>

<p>Dark current accumulates within the sensor at a steady rate, which is usually measured in electrons/pixel/second. This causes the dark current level to vary linearly with exposure length:</p>
<p>TODO-Chart</p>
<p>Dark current is also related to temperature. I tested this effect by putting my camera in the freezer, waiting until it reached thermal equilibrium, and comparing the low-temperature dark frames to ones taken at room temperature.</p>
<p>TODO-Chart</p>
<p>Many dedicated astronomy cameras feature built-in cooling to minimize dark current for this reason.</p>
<h2 id="read-noise">Read Noise <a class="section-link" href="#read-noise">&sect;</a></h2><p>There is also a small amount of unwanted signal that is produced by the amplification and ADC circuitry. The level of read noise is primarily determined by the sensor gain/ISO.</p>
<p>TODO-Chart</p>
<h1 id="calibration">Calibration <a class="section-link" href="#calibration">&sect;</a></h1><p>Now that we understand all the problems affecting our image, we can start getting rid of them. We&#39;ll start with dark current and read noise. The level of these two signals can be estimated by taking exposures at the same length and ISO as our light frames, but with the lens cap on. We will then combine these <strong>dark frames</strong> into a single master dark frame that we subtract from each light frame. Here&#39;s how the image looks after dark frame subtraction:</p>
<p>Now let&#39;s zoom out&hellip;</p>
<p>TODO-Image</p>
<p>&hellip;yikes. We&#39;ve got some pretty severe vignetting! This generally happens because our optics transmit less light towards the edges of the image. On a smaller level, our images also suffer from <strong>photo response non-uniformity (PRNU)</strong>, where different pixels have different sensitivity to light. We can correct both of these problems by taking pictures of a uniform source of illumination. This yields a <strong>flat frame</strong>, which we can divide our image by to neutralize the vignette and PRNU.</p>
<p>Of course, the flat frames themselves need to be calibrated. Specifically, we need to take dark frames using the same settings as the flat frames and perform dark-frame subtraction. This is what our final calibration pipeline looks like:</p>
<p>TODO-Pipeline</p>
<h1 id="alignment">Alignment <a class="section-link" href="#alignment">&sect;</a></h1><p>Now that our light frames are calibrated, we are ready to combine them. There&#39;s one problem, though: due to tracking errors, our light frames may be at different alignments, which we must detect and adjust by translating or rotating the images. </p>
<p>To do that, we must first accurately detect the </p>
<h1 id="stacking">Stacking <a class="section-link" href="#stacking">&sect;</a></h1><h1 id="post-processing">Post-processing <a class="section-link" href="#post-processing">&sect;</a></h1><img id="img-view" style="display: none"></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/astro">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>