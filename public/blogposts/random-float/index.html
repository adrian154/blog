<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Generating Random Floats in [0, 1)</title><meta property="og:title" content="Generating Random Floats in [0, 1)"><meta property="og:type" content="website"><meta property="og:description" content="It's time to get real. *badum tss*"><meta name="description" content="It's time to get real. *badum tss*"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/random-float"></head><body><header><a href="/"><img src="/images/banner.jpg" alt="blog banner"></a></header><main><p id="date" class="date">August 7, 2022</p><h1 style="margin-top: 0">Generating Random Floats in [0, 1)</h1><nav><div id="contents"><p>Table of Contents</p><a href="#introducing-floating-point"><p>Introducing Floating Point</p></a><a href="#actually-generating-floats"><p>Actually Generating Floats</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p>Recently, I found myself in a situation where I needed to generate a random <code>float</code> between 0 and 1 using a random 32-bit integer in C. This subject has been done to death before, but I felt like feeling a little pain so I decided to figure it out myself before using someone else&#39;s better solution.</p>
<p>First things first: we actually need to obtain some random integers. Easy, right? We&#39;ll just call <code>rand()</code> and&mdash;</p>
<figure style="max-width: 512px">
    <img src="eric-andre.gif" alt="GIF of Eric Andre shooting Hannibal">
    <figcaption>This is what will happen to you if you even suggest using C's rand().</figcaption>
</figure>

<p>rand() is known to have <a href="https://stackoverflow.com/questions/52869166/why-is-the-use-of-rand-considered-bad">a number of problems</a>; here&#39;s a short list:</p>
<ul>
<li>If you use glibc like me, your <code>rand()</code> uses a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator</a>. LCGs are very simple, but they are prone to subtle correlation issues that tend to manifest when applied to a multidimensional problem, such as Monte Carlo simulations.</li>
<li><code>srand()</code> takes an <code>unsigned int</code>, restricting the number of possible sequences you can get from <code>rand()</code> to number of distinct seeds that you can provide. For reference most quality PRNGs have an internal state of at least 128 bits, which is almost certainly larger than the size of an <code>unsigned int</code> on your platform.</li>
<li><code>rand()</code> is not thread safe; calling it will result in reads and writes to a shared location. Not only will this affect performance, it will also cause insidious randomness issues that may choose to emerge at the most inconvenient time. <code>rand_r()</code> allows the user to provide a pointer that will be used to store the PRNG&#39;s state, allowing thread-safe code to be written, but many programmers are seemingly not aware of this fact.</li>
</ul>
<p>Okay, so <code>rand()</code> is not as <em>horrible</em> as I&#39;ve made it out to be. Don&#39;t get me wrong&mdash;<code>rand()</code> is pretty crappy, but if you generated 100 random numbers and stared at it, it would probably look pretty random. So <code>rand()</code> might be okay for use cases where high quality randomness is not required (such as a game), but if you try subjecting it to <a href="https://en.wikipedia.org/wiki/TestU01">rigorous statistical tests</a> it crumples like wet toilet paper.</p>
<aside>

<p>Aside from <code>rand()</code>&#39;s inherent issues, common practices associated with it are often the source of additional evil. Common culprits are seeding the PRNG with unsuitable values or using the modulo operator to generate random numbers within a certain range. That&#39;s right&mdash;unless <code>RAND_MAX</code> is an exact multiple of your range, you are actually introducing a small amount of bias. But I digress&hellip;</p>
</aside>

<p>Today, we&#39;re going to be using <a href="https://prng.di.unimi.it/xoshiro128plus.c">xoshiro128+</a> as our PRNG. Admittedly, the choice of PRNG is not actually that important, which may come as a surprise after my rant about <code>rand()</code>. However, as long as you are not using a crappy or obscure generator, there are plenty of very fast, well-proven generators that will probably all be sufficient for your application.</p>
<h1 id="introducing-floating-point">Introducing Floating Point <a class="section-link" href="#introducing-floating-point">&sect;</a></h1><p>Okay, great. So now we have a random <code>uint32_t</code>... how do we turn this into a random <code>float</code>?</p>
<p>The na&iuml;ve solution is to just divide the integer by the maximum value (2<sup>32</sup>), but this is not great for two reasons:</p>
<ul>
<li>Division is slow.</li>
<li>This requires casting the integer to a float, but floats themselves are also 32 bits, so a float could not possibly represent all 32-bit integers. You can avoid this precision loss by casting to a double, but that just makes the first issue worse.</li>
</ul>
<p>Instead, what we want to do is create a floating point number using bitwise operations. To do that, we need to familiarize ourselves with how floating point values are represented in memory; specifically, we&#39;re going to be focusing on <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, which is sort of required in the C standard.</p>
<figure style="max-width: 640px">
    <img src="float-layout.png" alt="diagram of the bits in a floating-point number (sign, exponent, mantissa)">
    <figcaption>The anatomy of a single-precision float. <a href="https://en.wikipedia.org/wiki/File:Float_example.svg">Image</a> by <a href="https://en.wikipedia.org/wiki/User:Fresheneesz">Fresheneesz</a></figcaption>
</figure>

<p>If you ever learned scientific notation in school, a floating point number is a lot like that. Basically, a number is carved into three parts: the sign bit, the exponent, and the integer. The function of the sign bit is very simple; 0 is positive and 1 is negative. The real value represented by a float is basically equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mrow><mo>×</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathrm{fraction} \times 2^\mathrm{exponent}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">fraction</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7936em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">exponent</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>There are a few pitfalls that we need to be aware of, however:</p>
<ul>
<li>The exponent is stored with an offset of 127, so an exponent of 0 is equal to -127, an exponent of 127 is equal to 0, and an exponent of 255 is equal to 128. </li>
<li>The fraction section is interpreted as if there was an additional 1 bit in front of it.</li>
</ul>
<p>In this case, the exponent portion is equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>124</mn><mo>−</mo><mn>127</mn><mo>=</mo><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">124 - 127 = -3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">124</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">3</span></span></span></span>, and the fraction section is equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.0</mn><msub><mn>1</mn><mn>2</mn></msub><mo>=</mo><mn>1.25</mn></mrow><annotation encoding="application/x-tex">1.01_2 = 1.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">1.0</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.25</span></span></span></span>. Thus, the overall value is equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>×</mo><mn>1.25</mn><mo>=</mo><mn>0.15625</mn></mrow><annotation encoding="application/x-tex">2^{-3} \times 1.25 = 0.15625</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.25</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.15625</span></span></span></span>.</p>
<aside>

<p>Check out this <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">nifty online demo</a> that lets you toggle the bits in a floating point number to see how it affects the value.</p>
</aside>

<h1 id="actually-generating-floats">Actually Generating Floats <a class="section-link" href="#actually-generating-floats">&sect;</a></h1><p>As usual, I&#39;ve managed to stretch what ought to be a simple blogpost into a long-winded rag about unrelated stuff... bummer. Okay, let&#39;s actually generate some floats.</p>
<p>We can start by drawing 23 bits from our PRNG for the fraction part. This is easy enough; we just take a 32-bit value and shift it right 9 bits. This gives us a random fraction value between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.000</mn><msub><mo>…</mo><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1.000\ldots_2 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">1.000</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner">…</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.111</mn><msub><mo>…</mo><mn>2</mn></msub><mo>≈</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1.111\ldots_2 \approx 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">1.111</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner">…</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>.</p>
<p>If we set the exponent portion to 0, the fraction portion will be multipled with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, giving us a random number in the range <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[1, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>. We can easily turn into our desired value in range <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> by subtracting 1.</p>
<p>Here&#39;s the actual code:</p>
<pre><code class="hljs"><span class="hljs-type">float</span> <span class="hljs-title function_">int_to_float</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> random)</span> {
    <span class="hljs-class"><span class="hljs-keyword">union</span> {</span> <span class="hljs-type">uint32_t</span> u32; <span class="hljs-type">float</span> f; } u = { .u32 = random &gt;&gt; <span class="hljs-number">9</span> | <span class="hljs-number">0x3f800000</span> };
    <span class="hljs-keyword">return</span> u.f - <span class="hljs-number">1.0</span>;
}</code></pre><p><code>0x3f800000</code> is what we get when we take our exponent (0 is represented as 127) and shift it right 23 bits so that it&#39;s in the right place.</p>
<p>We could use plain old floating point multiplication instead of type punning, though there is a chance that it will be imperceptibly slower than our hacky solution. Probably not. Whatever.</p>
<p>You can find the full code demonstrating this concept <a href="xoshiro128plus.c">here</a>. That&#39;s all, folks. </p>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>