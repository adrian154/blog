<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>The Internet, Explained</title><meta property="og:title" content="The Internet, Explained"><meta property="og:type" content="website"><meta property="og:description" content="So what makes this thing tick, anyways?"><meta name="description" content="So what makes this thing tick, anyways?"><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><link rel="stylesheet" href="/stylesheets/packetview.css"><link rel="preconnect" href="https://rsms.me/"><link rel="stylesheet" href="https://rsms.me/inter/inter.css"><script defer src="/scripts/packetview.js"></script><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/internet-explained"></head><body><header><h1 id="post-title">The Internet, Explained</h1><p class="date">Published January 4, 2022 &bull; <a href="/">more posts</a></p></header><main><p>Some time ago, it occurred to me that I didn&#39;t <em>really</em> understand what made the Internet work. Sure, I am all too familiar with what the user experience is like, and my adventures in web development have forced me to acquire a bit of networking knowledge, but between the bits of light here and there existed vast chasms of confusion. So I decided to do some reading, some soul-searching, and publish my findings in the form of a blog post.</p>
<p>The word &quot;internet&quot; itself offers some hints about its architecture. &quot;Internet&quot; is short for <em>internetworking</em>, the act of unifying numerous computer networks under one protocol. That&#39;s essentially what the Internet is, a bunch of independently maintained networks that are joined together such that any two computers on the Internet can reach each other, even if the physical protocols that the two devices use to reach their peers are completely incompatible.</p>
<h1 id="physical-layer">Physical Layer <a class="section-link" href="#physical-layer">&sect;</a></h1><p>Let&#39;s start from the very bottom. No Internet, no networks even. Our goal is to simply transfer some information from point A to point B. It turns out that there are incredibly many ways to accomplish this, each with its own strengths and weaknesses.</p>
<p>In the context of the Internet, we refer to the rules which govern how data is encoded and transmitted through a physical medium as the <strong>physical layer</strong>. This involves everything from the actual connectors or radio bands used for communication, to the <a href="https://en.wikipedia.org/wiki/Line_code">line codes</a> which specify how to extract a bitstream from the measured values of a signal.</p>
<p>The physical layer is closely tied to the <strong>link layer</strong>, which leverages the physical layer&#39;s capabilities to transfer discrete units of data (&quot;frames&quot;) over a network, especially one with topology more complicated than a single point-to-point link. It may also take on responsibilities such as error correction and automatic retransmission.</p>
<aside>

<p>For every network, there is a maximum frame size that it can accept, known as the <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">maximum transmission unit</a> or MTU. This is an important property of the link-layer network that higher layers need to be aware of.</p>
</aside>

<p>The physical layer and link layer are generally tightly coupled (out of necessity), which is the source of endless frustration. For example, the term &quot;Ethernet&quot; might refer to the physical cable standard, but it could also refer to the Ethernet protocol used to transfer frames over those cables. Which is it?</p>
<p>The full answer is that Ethernet spans several network layers, because it supports a variety of physical transmission media. There&#39;s of course the classical <a href="https://en.wikipedia.org/wiki/Category_6_cable">twisted pair cable</a>, but Ethernet also works over coaxial cable and optical fiber. Ethernet itself belongs to a bigger group of <a href="https://en.wikipedia.org/wiki/IEEE_802">IEEE 802</a> technologies, which also includes protocols like Wi-Fi. All IEEE 802 protocols implement a link-layer interface called <strong>medium access control</strong> (MAC), allowing interoperation between them.</p>
<p>Under MAC, each network interface has a unique 48-bit identifier known as a MAC address. These addresses are allocated by IEEE to manufacturers of network equipment, though some mobile devices simply generate a <a href="https://support.apple.com/guide/security/wi-fi-privacy-secb9cb3140c/web">random MAC address</a> for privacy reasons. We&#39;ll see how MAC addresses are used in routing later.</p>
<p>Beyond Ethernet, there are no shortage of other physical and link-layer technologies. Here are some prolific examples:</p>
<ul>
<li>WiFi (<a href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a>)</li>
<li>Cable (<a href="https://en.wikipedia.org/wiki/DOCSIS">DOCSIS</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/LTE_(telecommunication)">LTE</a></li>
</ul>
<p>There are also plenty of obscure and dead LAN technologies. One example is <a href="https://en.wikipedia.org/wiki/Token_Ring">Token Ring</a>, IBM&#39;s Ethernet competitor, which was famously vanquished around the turn of the century.</p>
<h1 id="switches">Switches <a class="section-link" href="#switches">&sect;</a></h1><figure style="max-width: 800px">
    <img loading="lazy" src="ethernet-switch.jpg" alt="ethernet switch">
    <figcaption>An Ethernet switch. <a href="https://commons.wikimedia.org/wiki/File:Netgear_Gigabit_Switch_5-port.jpg">Image</a> by <a href="https://commons.wikimedia.org/wiki/User:LivingShadow">Simon A. Eugster</a> / <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">CC-BY</a></figcaption>
</figure>

<p>Devices called <a href="https://en.wikipedia.org/wiki/Network_switch">network switches</a> allow communication between interfaces on the same LAN. A switch is basically an embedded device with a large number of Ethernet ports. Because all devices on the network communicate with each other by talking through the switch, a <a href="https://en.wikipedia.org/wiki/Star_network">star topology</a> is formed.</p>
<figure style="max-width: 481px">
    <img loading="lazy" src="switch-star-topology.png" alt="star topology diagram">
    <figcaption>In case you can't tell, I'm not exactly the best at making diagrams.</figcaption>
</figure>

<p>Ethernet frames are fairly simple in structure. Each frame contains the source MAC address and destination MAC address (along with other fields such as a checksum) before the payload, so that the frame can be routed to the correct recipient. </p>
<p>When computer A wants to send a message to computer B, it sends a frame to the switch with computer B&#39;s MAC address. However, the switch doesn&#39;t know which physical port the connection to computer B is located on, so it relays the frame to every connected device in hopes that one of them is the intended recipient (a practice known as flooding). When computer B receives the frame, it might reply with another frame. That frame would contain computer B&#39;s MAC address as the source, allowing the switch to internally associate the physical port it received the frame on with computer B&#39;s MAC address. In the future, when the switch receives a frame with computer B as its destination, it knows exactly where to send the frame.</p>
<aside>

<p>Back in the day, when everything was slightly worse, networks were often created using <a href="https://en.wikipedia.org/wiki/Ethernet_hub">hubs</a> instead of switches. Hubs are much simpler devices which simply retransmit everything that it receives on every port. Because of their relative lack of sophistication, hubs suffer from a littany of problems:</p>
<ul>
<li>Since every device needs to be able to receive the data being transmitted by the hub, if one device was slower than the others, <em>every</em> link on the switch would be forced to operate at that speed.</li>
<li>Multiple devices trying to transmit at the same time would result in both devices talking over each other (a condition known as a collision), requiring them to detect the conflict and stop transmitting. Collisions were avoided using a protocol known as <a href="https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection">Carrier-Sense Multiple Access with Collision Detection</a>, or CSMA/CD. &quot;Carrier-Sense&quot; refers to how transmitting devices were responsible for detecting a colliding signal and stopping their transmission. This resulted in degraded network performance as more devices were attached to the hub.</li>
</ul>
<p>Today, hubs have been made obsolete in favor of switches and are rarely used outside of special conditions (though evidently my school&#39;s IT department hasn&#39;t gotten the memo). Even in the early days of Ethernet, it was apparent that collisions posed a challenging problem, so other protocols approached access control differently. For example, in Token Ring setups, there is no central switch or hub; nodes are connected in a ring, and transmission rights are passed around the ring, so no collisions were possible. When one node was done transmitting, it passed the <em>token</em> to the next node, hence the name &quot;Token Ring&quot;.</p>
</aside>

<p>Switches are one of the most ubiquitous building blocks of computer networks, so it&#39;s no surprise that they are all over the place. If your router has more than one Ethernet port, chances are it has a built-in switch.</p>
<h2 id="wifi">WiFi <a class="section-link" href="#wifi">&sect;</a></h2><p>Ethernet is <em>the</em> most common standard for wired communications, but most people access their network wirelessly when at home. So let&#39;s talk about WiFi, which is standardized in <a href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a>. The biggest difference in wireless networking is that for the purposes of a residential LAN, point-to-point links don&#39;t exist. Instead, devices communicate with the LAN by broadcasting on a predetermined frequency. All devices on the LAN receive and decode incoming frames, and simply filter out the ones which aren&#39;t intended for them.</p>
<p>However, this comes with the pitfall that only one device can transmit at a time on a given channel. The situation is similar to what happens when multiple people try to have a conversation in a small room. WiFi can&#39;t use CSMA/CD either, because CSMA/CD relies on transmitters being able to listen for a colliding signal while transmitting; that&#39;s easy for wired network devices, which transmit and receive on physically isolated wires, but WiFi transceivers have to stop receiving while transmitting or they&#39;d only be able to hear their own signal. Thus, collision <em>avoidance</em> is used, where transceivers wait until the network has been quiet for some time before starting to transmit.</p>
<p><img loading="lazy" src="hidden-node-problem.png" alt="illustration of the hidden node problem"></p>
<p>Collision avoidance sometimes fails, though. Check out this diagram, where the red and blue circles represent the range which devices A and B can receive communications, respectively. Device A cannot hear device B, so it has no way to avoid transmitting at the same time as device B. If that happens, the device at the center (which is in range of both device A and device B) will be unable to decipher either device&#39;s transmission. This is called the <em>hidden node problem</em>.</p>
<p>To alleviate the hidden node problem, WiFi implements an algorithm called Request-to-Send/Clear-to-Send, or RTS/CTS. With RTS/CTS, every node asks the access point whether it&#39;s okay for them to transmit in combination with checking if the channel is quiet. Only when a clear-to-send message is received from the access point does the device send the packet. RTS/CTS is always used, but under the right conditions it is shown to give a fairly significant boost to network throughput.</p>
<p>Speaking of which, what <em>is</em> an access point, anyways? We&#39;ve already established that unlike in a wired network, a central switching point is not strictly necessary for wireless networks; every device includes a transceiver, so any two WiFi-enabled devices can talk to each other without external help. Instead, the job of a wireless access point is to serve as the gateway between the local network and greater Internet. Speaking of which&hellip;</p>
<h1 id="internet-layer">Internet Layer <a class="section-link" href="#internet-layer">&sect;</a></h1><p>We&#39;ve finally reached the Internet layer of the Internet. This is where all the action happens! Buckle up, and let&#39;s explore how it works.</p>
<p>Unsurprisingly, the Internet is powered by the <a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a>. There are actually two different versions of IP with widespread deployment: IPv4, and IPv6. The fundamental concepts are very similar, but there are important differences between the two protocols.</p>
<p>In IP, every network interface is associated with an IP address. In IPv4, this address is 32-bits long, and usually written as a series of four numbers (each corresponding to a byte or <em>octet</em> of the IP address) separated by periods. For example, the IP of this blog at the time of writing is 142.93.26.121. IP addresses are managed by the <a href="https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority">Internet Assigned Numbers Authority</a>, which assigns blocks of IP addresses to the five <a href="https://en.wikipedia.org/wiki/Regional_Internet_registry">Regional Internet Registries</a>. The RIRs, in turn, deal with requests from individuals and businesses for IP allocations.</p>
<p>Because IPv4 addresses are only 32 bits long, there can only be 2<sup>32</sup> = ~4 billion unique IPv4 addresses. That seems like a lot, but as early as the 90s the threat of running out of IPv4 addresses has continually loomed over the Internet, made worse by the fact that many parts of IPv4 space are <a href="https://en.wikipedia.org/wiki/Reserved_IP_addresses">reserved</a> for various purposes.</p>
<figure style="max-width: 740px">
    <img loading="lazy" src="xkcd-internet-map.jpg" alt="xkcd internet map">
    <figcaption><a href="https://xkcd.com/195/">xkcd 195</a>: a map of IPv4 space circa 2006. Things have only gotten more crowded since then.</figcaption>
</figure>

<p>To fix this issue, IPv6 was created. IPv6 addresses are 128 bits long, which is more than enough to serve humanity&#39;s needs at the moment; for reference, you could assign each human alive a trillion IPv6 addresses and it wouldn&#39;t even scratch 1% of the full IPv6 space. IPv6 addresses are written as a series of two-octet groups, like <code>2607:f8b0:4005:080b:0000:0000:0000:200e</code>. Sequential groups of zeroes can omitted, so the previous address would be written as <code>2607:f8b0:4005:80b::200e</code>.</p>
<aside>

<p id="v4-addr" style="display: none">Your IPv4 address is <code></code>.</p>

<p id="v6-addr" style="display: none">Your IPv6 address is <code></code>.</p>

<p><noscript>Enable JavaScript to see your IPv4 and IPv6 address here!</noscript></p>
<script>
const showIP = (elem, value) => {
    elem.style.display = "";
    elem.querySelector("code").textContent = value;
};

const showErr = (elem, v6) => {
    elem.style.display = "";
    elem.textContent = v6 ? "Your IPv6 address could not be determined. You probably don't have it." : "Your IPv4 address could not be determined.";
};

const v4addr = document.getElementById("v4-addr"), 
      v6addr = document.getElementById("v6-addr");

fetch("https://v4-api.bithole.dev/ip").then(resp => resp.text()).then(ip => showIP(v4addr, ip)).catch(() => showErr(v4addr));

fetch("https://v6-api.bithole.dev/ip").then(resp => resp.text()).then(ip => showIP(v6addr, ip)).catch(() => showErr(v6addr, true));
</script>

</aside>

<h2 id="packets">Packets <a class="section-link" href="#packets">&sect;</a></h2><p>One of the key innovations that made the Internet possible was <a href="https://en.wikipedia.org/wiki/Packet_switching">packet switching</a>. The idea behind packet switching is to split digital data to be transferred into discrete chunks, or packets. Whenever a machine receives a packet, it consults its routing table to determine which host to send the packet to next. Thanks to its ubiquity, packet switching probably seems fairly mundane to most programmers today, but at the time (when the predominant paradigm for telecommunications was <a href="https://en.wikipedia.org/wiki/Circuit_switching">circuit switching</a>), packet switching was revolutionary.</p>
<p>Compared to circuit switching, packet switching allows for much more diverse network topologies. This is because each packet is delivered independently, so they can take whatever route happens to be best at the moment. Compare that to a telephone call, where a physical circuit is established between the two parties and maintained for the duration of the call. Packet switching also makes it easy to bridge networks running different link-layer protocols. All of these attributes have helped the Internet scale to billions of connected devices.</p>
<p>So what&#39;s <em>in</em> a packet? Well&hellip; see for yourself! Here, I&#39;ve got a Ethernet frame produced by the <code>ping</code> command. The Ethernet header is orange. Within the frame is an IPv6 packet (blue), which contains an ICMPv6 message (purple).</p>
<p><strong>Guide</strong>: Click on a section of the packet to see a description of its significance. Click the hex preview on the left to return to the top. Try enabling &quot;show all&quot; if you want to read all the section descriptions.</p>
<div class="packet">
<div class="segment" data-part="ethernet" data-hex="402b50dc01dc" data-name="Destination MAC">

<p>The destination MAC address, my router.</p>
</div>
<div class="segment" data-part="ethernet" data-hex="80ce62320df8" data-name="Source MAC">

<p>The source MAC address, my laptop.</p>
</div>
<div class="segment" data-part="ethernet" data-hex="86dd" data-name="Type">

<p>The type of data contained within the frame. <code>0x86dd</code> indicates that the frame contains an IPv6 packet.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="60064d6f" data-name="Version / Traffic Class / Flow Label">

<p>The upper 4 bits of these bytes indicate the Internet Protocol version in use. In this case, it&#39;s 6 for IPv6.</p>
<p>The next 8 bits are the traffic class, which gives routers hints about how the packet should be handled. For example, a video conferencing application might set this field to prioritize low latency over delivery reliability. In this case, the value is set to zero, which is the default value (best effort).</p>
<p>The last 20 bits are the flow label (<code>0x64d6f</code>). Flow labels are pseudorandom numbers that serve to group packets belonging to the same &quot;flow&quot;. For example, all the packets in a TCP session might be sent with the same flow label. This is mainly used for quality-of-service purposes.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="0040" data-name="Payload Length">

<p>The length of the IPv6 packet&#39;s payload, 64 bytes in this case.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="3a" data-name="Next Header">

<p>In this packet, the IPv6 header is followed immediately by the packet payload, so the Next Header value is equal to <code>0x3a</code> since that is the assigned number for ICMPv6.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="40" data-name="Hop Limit">

<p>The hop limit is a special field which is used to mitigate the effects of <a href="https://en.wikipedia.org/wiki/Routing_loop">routing loops</a>. Every time a router forwards an IPv6 packet, it decrements the hop limit by one. Once the value reaches zero, if it still hasn&#39;t reached the destination host, the packet is discarded. </p>
<p>In IPv4 packets this field is called the time-to-live (TTL), so you will see the same concept referred to by two different names.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="2601064246010210889f9e722b7649dc" data-name="Source Address">

<p>The IPv6 address of the host sending the packet.</p>
</div>
<div class="segment" data-part="ipv6" data-hex="2604a880000200d0000000000eac6001" data-name="Destination Address">

<p>The IPv6 address of the destination host. In this case, it&#39;s the IPv6 address of <code>bithole.dev</code>.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="80" data-name="Type">

<p>The type of ICMPv6 packet. <code>0x80</code> equals Echo Request, meaning that the client is requesting that the server respond with another ICMP packet to test the connection between the two.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="00" data-name="Code">

<p>This field is always zero for echo requests.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="e2fe" data-name="Checksum">

<p>A two-byte checksum value is calculated and included with every ICMPv6 message. This allows recipients to determine if the packet has been corrupted in transit.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="0004" data-name="Identifier">

<p>When the server receives the Echo Request, it will send back an Echo Reply with the same identifier. This helps match echo replies with echo requests.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="0013" data-name="Sequence Number">

<p>Similar to the identifier, this is another field used to distinguish echo requests/replies.</p>
</div>
<div class="segment" data-part="icmpv6" data-hex="1c7fdc620000000094fd010000000000101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637" data-name="Data" data-preview-truncate="39">

<p>Arbitrary data that the server will also include in the echo reply, hence &quot;echo&quot;.</p>
</div>
</div>

<p>For this illustration I chose to use an IPv6 packet since they are slightly simpler than IPv4 packets, but the fields contained are basically the same. There is one key difference, however: IPv4 also supports a feature called <em>fragmentation</em>. Remember what I mentioned earlier about the maximum transmission unit (MTU)? MTUs are not consistent everywhere, so occasionally a router may encounter a scenario where it is unable to relay an IP packet as-is because it is too large to fit within the next link&#39;s MTU. In that situation, IPv4 routers may choose to break the packet into multiple smaller fragments, which will be reassembled later down the line.</p>
<p>Fragmentation is not free, however. Not only does fragmentation increase overhead, it can exacerbate problems such as packets arriving out of order. Worse, applications that don&#39;t properly handle fragmented packets (such as firewalls) may be vulnerable to <a href="https://en.wikipedia.org/wiki/IP_fragmentation_attack">fragmentation attacks</a>. For this reason, IPv6 routers are not allowed to fragment packets; if a packet is too big to be relayed, an error is sent to the sender through ICMPv6. Hosts are responsible for determining the largest packet that can be transmitted by the routers between the source and the recipient. This process is known as <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">path MTU discovery</a>.</p>
<h2 id="obtaining-an-ip-address">Obtaining an IP address <a class="section-link" href="#obtaining-an-ip-address">&sect;</a></h2><p>In order to send or receive IP traffic, you first need an IP address. Your computer could obtain one through several methods:</p>
<ul>
<li>It is configured to use a specific static IP address.</li>
<li>It receives an IP address while connecting to the network, via the <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Dynamic Host Configuration Protocol</a> (DHCP).</li>
<li>(other less straightforward schemes)</li>
</ul>
<p>Let&#39;s talk about DHCP. DHCP is built on top of UDP, which in turn resides above IP. It allows newly-connected clients to contact the local DHCP server and obtain an IP address. Right off the bat, there are two challenges:</p>
<ul>
<li>How can the computer send/receive DHCP packets, which are carried via IP, if it doesn&#39;t have an IP address yet?</li>
<li>How does the computer discover the DHCP server?</li>
</ul>
<p>To solve the first problem, clients use a source IP of 0.0.0.0 in their initial DHCP requests. The DHCP server distinguishes incoming requests not by source IP but by MAC address. To discover the DHCP server, all DHCP requests are directed to a special IPv4 address, 255.255.255.255, which broadcasts the packets to all nodes on the network. By seeing which IP replies, a device can figure out which IP the DHCP server is running on.</p>
<p>Okay, so we&#39;ve obtained an IP address. Now what?</p>
<p><img loading="lazy" src="ip-lan.png" alt="diagram of an IP LAN"></p>
<p>Suppose computer 10.0.0.2 wants to send a message to 10.0.0.3. In order to actually deliver a message to 10.0.0.3, our sender needs to know which MAC address to send packets to. It can obtain this information via the <a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">Address Resolution Protocol</a> (ARP).</p>
<h2 id="obtaining-an-ip-address-ipv6-style">Obtaining an IP Address, IPv6 Style <a class="section-link" href="#obtaining-an-ip-address-ipv6-style">&sect;</a></h2><p>DHCP exists for IPv6 in the form of DHCPv6, but several alternative ways to obtain an address are also provided. In this section, we&#39;re going to be covering StateLess Address AutoConfiguration (SLAAC).</p>
<p>TODO</p>
<h2 id="address-resolution-protocol">Address Resolution Protocol <a class="section-link" href="#address-resolution-protocol">&sect;</a></h2><p>If you want to send a packet to some IP address, the process goes something like this:</p>
<ul>
<li>Determine which MAC address represents that IP</li>
<li>Create the IP packet</li>
<li>Encapsulate the IP packet in an Ethernet frame</li>
<li>Send the frame to that MAC address</li>
</ul>
<p>How do we look up the MAC address for a given IP? This is where the Address Resolution Protocol (ARP) steps in. ARP operates on the link layer, meaning that ARP packets are not encapsulated in IP packets. When a computer needs to determine the MAC address for an IP address, it broadcasts an ARP request to the local network. This is done by sending frames addressed to a MAC address of FF:FF:FF:FF:FF:FF, which signals to the switch that the message should be relayed to all connected devices. The device which has the corresponding IP responds to the request with its MAC and IP address. Both of these devices may cache each others&#39; IP and MAC addresses to avoid making another ARP request in the future. In the future, when a device joins a network or obtains a new IP address, it may publish an ARP announcement that prompts all other devices to update their ARP caches.</p>
<aside>

<p>One major weakness of ARP is its vulnerability to <a href="https://en.wikipedia.org/wiki/ARP_spoofing">spoofing attacks</a>, wherein a malicious device publishes an ARP announcement or responds to an ARP request not intended for them in order to masquerade as another device. For this reason, IPv6 uses <a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">Neighbor Discovery Protocol</a> (NDP) instead of ARP. NDP seeks to address some of the security and usability problems which have traditionally affected ARP. To learn more, check out <a href="https://superuser.com/questions/969831/why-is-arp-replaced-by-ndp-in-ipv6">this thread</a> on StackExchange.</p>
</aside>

<p>ARP is ubiquitous among IEEE 802 networks. If your computer is on a WiFi or Ethernet-based network, you can install <a href="https://www.wireshark.org/">Wireshark</a> and observe ARP requests happening right before your eyes.</p>
<figure style="max-width: 878px">
    <img loading="lazy" src="arp-capture.png" alt="arp requests on my LAN, as seen by wireshark">
    <figcaption>Some ARP requests seen on my local network.</figcaption>
</figure>

<p>Your computer doesn&#39;t make an ARP request for every single outgoing IPv4 connection. If configured correctly, your computer should be able to tell which addresses belong to the local network (i.e. they can be reached by MAC address) and which reside on the public internet. </p>
<h2 id="introduction-to-cidr">Introduction to CIDR <a class="section-link" href="#introduction-to-cidr">&sect;</a></h2><p>During the Internet&#39;s infancy, the format of IP addresses was much simpler. As seen in <a href="https://datatracker.ietf.org/doc/html/rfc760#section-3.1">RFC 760</a>, published in January 1980, the first 8 bits of each IP address identified which network it originated from, and the remaining 24 bits were unique to each host. This limited the Internet to just 256 networks (technically 254 since addresses beginning with 0 are reserved for local use and addresses beginning with 255 are used for broadcast). It soon become apparent that the Internet would grow to encompass much more than just 256 networks, so the <a href="https://en.wikipedia.org/wiki/Classful_network">classful network</a> scheme was adopted.</p>
<p>Under classful networking, each network belongs to one of three classes:</p>
<ul>
<li>Class A: The first 8 bits of the IP address identify the network, leaving 24 bits = 16,777,216 addresses for host identification.</li>
<li>Class B: The first 16 bits of the IP address identify the network, leaving 16 bits = 65,536 addresses for host identification.</li>
<li>Class C: The first 24 bits of the IP address identify the network, leaving 8 bits = 256 addresses for host identification.</li>
</ul>
<p>(The actual scheme had some more details which are omitted here.)</p>
<p>Eventually, engineers realized that the classful networking scheme was still rather inefficient; the size difference between classes was far too granular, and many IP addresses were going to waste. So classful networks were done away with, and a new system, <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a> (CIDR), was adopted.</p>
<p>Under CIDR, the number of network/host bits is variable, instead of being fixed at 8, 16, or 24. This allowed IPs to be allocated with much less overhead. In CIDR notation, the length of the network prefix is written after the IP and separated with a slash. For example, the IP of this server at the time of writing is 142.93.26.121. It belongs to a bigger subnet, 142.93.16.0/20, which encompasses all IP addresses whose first 20 bits match those of 142.93.16.0. The length of this network&#39;s prefix is 20 bits, leaving 12 bits for hosts on the subnet, which gives it a maximum capacity of 2<sup>12</sup> = 4096 hosts.</p>
<p>Complementary to CIDR is the idea of a <em>netmask</em>. For a given classless network, its netmask is a special 32-bit value where all the prefix bits are set to 1 while all the host bits are cleared. The routing prefix of an address can be obtained by finding the bitwise AND of the address and the netmask. If the routing prefix doesn&#39;t match that of the local network, your computer won&#39;t perform an ARP lookup, since only machines on the same LAN can be contacted via MAC address.</p>
<aside>

<p>Check out my <a href="https://bithole.dev/tools/cidr.html">CIDR calculator</a>, which performs a number of useful operations given a CIDR range.</p>
</aside>

<h2 id="going-public">Going Public <a class="section-link" href="#going-public">&sect;</a></h2><p>So what happens when your computer encounters an IP that isn&#39;t on the LAN? Thankfully for your poor computer, handling the routing of this packet across the public Internet is mostly outside of its responsibilities. Your computer has a <a href="https://en.wikipedia.org/wiki/Default_route"><em>default route</em></a>, which specifies who to contact to relay packets outside the local network. That device is called the <strong>default gateway</strong>, since it serves as a gateway to the rest of the world.</p>
<aside>

<p>Your computer uses the default gateway&#39;s IP (which can be printed via <code>ipconfig</code> on Windows or <code>ip a</code> on Linux) to figure out its MAC address via ARP. However, the IP packets sent to the default gateway still have the final recipient&#39;s IP address, since obviously the default gateway needs to know who to send it to.</p>
<p>Many residential routers also serve a management page from the default gateway IP. This is purely by convention. The router can distinguish traffic to the gateway itself and traffic to the public internet by looking at the destination address of incoming packets.</p>
</aside>

<p>Your router itself has a default gateway, too. In fact, your router&#39;s view of the internet isn&#39;t really different from that of your computer&#39;s: it too is just part of a bigger network, owned by your ISP instead of you. Other than that, pretty much all the other details stay the same; your router has a subnet mask, it performs ARP requests, and it relays packets which aren&#39;t on its network to the default gateway. In fact, your router probably obtains its address from the ISP through DHCP as well. (That&#39;s why rebooting your router may result in your home network being assigned a new IP address. Realistically, however, most routers remember their previous IP address and simply request the same one when they boot up again.)</p>
<aside>

<p>Access to the ISP&#39;s network is controlled via MAC address. Because of this, if you choose to use your own router instead of your ISP&#39;s equipment, you may have to contact them so that they can add your router&#39;s MAC address to their records. Conversely, if you know the MAC address of a subscriber on the same WAN, you can spoof it to get free Internet. Be warned, though, this is <a href="https://www.techdirt.com/articles/20140616/06521227593/when-aaron-swartz-spoofed-his-mac-address-it-proved-he-was-criminal-when-apple-does-it-its-good-everyone.shtml">fairly illegal...</a></p>
</aside>

<h2 id="nat-a-perpetual-annoyance">NAT: A Perpetual Annoyance <a class="section-link" href="#nat-a-perpetual-annoyance">&sect;</a></h2><p>Hey, remember IPv4 exhaustion? Yup. It&#39;s me again. Here to make your life slightly worse for the umpteenth time. <em>When will you learn?</em></p>
<p>As I write this blogpost, IPv6 will have been available for an entire decade in just a couple months, yet <a href="https://www.google.com/intl/en/ipv6/statistics.html">IPv6 adoption</a> still languishes at around 35%. As it stands, the <em>majority</em> of the Internet is only available over IPv4, yet IANA allocated all of its IP addresses to the RIRs in <a href="https://itp.cdn.icann.org/en/files/announcements/release-03feb11-en.pdf">2011</a>; <a href="https://www.ripe.net/">RIPE NCC</a>, one of the five RIRs, was the last to <a href="https://www.ripe.net/publications/news/about-ripe-ncc-and-ripe/the-ripe-ncc-has-run-out-of-ipv4-addresses">run out of addresses</a> in 2019. Nowadays, if you want to get your hands onto some IPv4 addresses, you&#39;ll have to turn to the <a href="https://auctions.ipv4.global/">IP aftermarket</a>, where you&#39;d be paying a price of anywhere from 40 to 120 bucks a pop. </p>
<p>This ever-worsening drought of IP addresses has forced the Internet&#39;s biggest players, the ISPs, to get creative. One solution that has been used to combat IPv4 exhaustion is <a href="https://en.wikipedia.org/wiki/Network_address_translation">Network Address Translation</a> (NAT). NAT precludes the need to assign every device on a household network a unique IP address. Here&#39;s how it works.</p>
<figure style="max-width: 481px">
    <img loading="lazy" src="nat.png" alt="nat diagram">
    <figcaption>A typical NAT setup.</figcaption>
</figure>

<p>Each device on the LAN has a private IP address. In this case, the addresses are from the 10.0.0.0/8 block, one of three blocks which are <a href="https://datatracker.ietf.org/doc/html/rfc1918">reserved</a> for use within private networks. These are not directly usable for accessing the internet; most networks are configured to <a href="https://en.wikipedia.org/wiki/Bogon_filtering">reject</a> packets originating from outside the network with a private IP. Instead, when the NAT router receives a packet from a device that is destined for the public Internet, it overwrites the original address with the router&#39;s public address before relaying it. This way, all the devices on the LAN can access the Internet through just one address.</p>
<p><em>But wait</em>, you might say. <em>When the router receives an incoming packet, how does it know which device to forward it to?</em> Ah. You&#39;ve stumbled across one of NAT&#39;s biggest flaws. The protocol that is being NATed must provide some way to keep track of which connection is which. For TCP, arguably the most common protocol on the Internet, this is done through the port number. For instance, if 10.0.0.1 makes a request to public IP 100.2.3.4, the router will overwrite both the source address in the IP header and the source port in the TCP header with an arbitrary, unique port. It will remember this port information and, when 100.2.3.4 sends a TCP response, the router can forward the packets to the appropriate device on the local network by reading which port they are addressed to.</p>
<p>The fact that the router must remember which port is associated with which local connection makes NAT <em>stateful</em>, which stands directly at odds with IP&#39;s <em>stateless</em> nature. Furthermore, NAT also violates the <a href="https://en.wikipedia.org/wiki/End-to-end_principle">end-to-end principle</a>, which states that protocol logic should only be handled at each end of the network route; intermediate nodes shouldn&#39;t need to know anything about the data they are relaying. Even worse, there are some protocols that simply don&#39;t work with NAT.</p>
<p>Finally, while NAT works reasonably well for consumers, it is for the most part fundamentally incompatible with server hosting, which requires listening on a <em>specific</em> well-defined port that often can&#39;t be changed. If you&#39;ve ever tried to host a Minecraft server out of your home network, you&#39;re probably familiar with this struggle. This hasn&#39;t stopped Google from offering <a href="https://cloud.google.com/nat/docs/overview">cloud NAT</a> for serving multiple unrelated services on different ports.</p>
<p>NAT doesn&#39;t have to stop at the residential level, though. Under <a href="https://en.wikipedia.org/wiki/Carrier-grade_NAT">carrier-grade NAT</a> (CGNAT), entire WANs are encapsulated under address translation, further reducing IPv4 address usage. IANA <a href="https://datatracker.ietf.org/doc/html/rfc6598">allocated</a> the 100.64.0.0/10 block for use with CGNAT in 2012.</p>
<h1 id="where-does-internet-actually-come-from">Where Does Internet Actually Come From? <a class="section-link" href="#where-does-internet-actually-come-from">&sect;</a></h1><p>We&#39;ve established that your router doesn&#39;t really do anything special, it just serves as a gateway between your LAN and your ISP&#39;s larger network. So how does your ISP get on the Internet? This is where things really start getting interesting.</p>
<p>So far, our trusty little packet has faced some pretty tough trials. He was disassembled and reassembled when he crossed the NAT firewall, and now he&#39;s being bounced around the ISP&#39;s internal network. How does he find his way to the Promised Land, the destination IP?</p>
<p>Routing within the ISP network may be driven by any one of several protocols. <a href="https://en.wikipedia.org/wiki/IS-IS">Intermediate System to Intermediate System</a> (IS-IS) and <a href="https://en.wikipedia.org/wiki/Open_Shortest_Path_First">Open Shortest Path First</a> (OSPF) are often used for internal routing, from what I gather, but information on the topology of ISP networks and how they manage their routes is scarce as expected. Both IS-IS and OSPF are <a href="https://en.wikipedia.org/wiki/Link-state_routing_protocol">link state routing protocols</a>, meaning that routers broadcast their links to the internal network, allowing other routers to build a map of the network and calculate the optimal route to each node using an algorithm such as <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a>.</p>
<p>But what if the destination isn&#39;t in the ISP&#39;s network?</p>
<h2 id="autonomous-systems">Autonomous Systems <a class="section-link" href="#autonomous-systems">&sect;</a></h2><p>At the very top level, the Internet is organized into <a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)">autonomous systems</a>. Generally, all the IPs within an AS are controlled by one organization (usually a corporation) and can reach each other without leaving the AS. The AS is defined by the list of routing prefixes that belong to the AS, and each AS is assigned a number (an ASN) by our good friend IANA.</p>
<aside>

<p>ASNs were initially 16-bit, but eventually it became obvious that the supply was about to run out, so IANA started allocating <a href="https://datatracker.ietf.org/doc/html/rfc4893">32-bit ASNs</a> in 2007.</p>
</aside>

<p>When you look at the Internet at the AS level, the illusion is truly stripped bare, and you can see the Internet for what it is: a bunch of servers, organized into ASes, with connections running between them.</p>
<p>Routing between ASes is universally done via the <a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">Border Gateway Protocol</a>, which is a <a href="https://en.wikipedia.org/wiki/Path-vector_routing_protocol">path vector routing protocol</a> as opposed to a link state routing protocol. Instead of broadcasting the existence of links throughout the network, BGP routers advertise which ASes they can reach and the path to take to their peers. This has the benefit of preventing the possibility of a loop, which would pose a serious problem at a global scale. In general, BGP is designed to reduce volatility in Internet routing. To reduce network usage and routing table size, BGP routers may use heuristics to selectively reject routes, a process known as <a href="https://en.wikipedia.org/wiki/Route_filtering">route filtering</a>. (The side-effect of route filtering is that no router on the Internet has a complete view of <em>all</em> routes, so collecting statistics on the routing table requires careful observation from numerous viewpoints.)</p>
<figure style="max-width: 801px">
    <img loading="lazy" src="routing-protocols.png" alt="interaction between internal and external networks">
    <figcaption>Diagram of the various routing protocols found on the Internet. Internal links are highighted in red; border routers are highlighted in green.</figcaption>
</figure>

<p>The BGP routing itself looks just like the routing table you&#39;d find on your router or computer, just <em>much bigger</em> (around 900,000 unique prefixes at the time of writing). Its functionality remains unchanged, though. When a border router receives a packet:</p>
<ul>
<li>If the packet is destined to the internal network, it relays the packet based on whatever routing protocol the AS internally uses.</li>
<li>Otherwise, it consults its routing table, finds the best next hop, and relays the packet to that BGP peer.</li>
</ul>
<p>Not every AS is connected with each other; often, Internet packets will travel through networks belonging to several ASes until they reach their destination. You can see this for yourself using the <a href="https://linux.die.net/man/8/traceroute">traceroute</a> utility. Many Internet infrastructure operators also run public <a href="https://en.wikipedia.org/wiki/Looking_Glass_server">Looking Glass</a> servers, which allow users to run traceroutes or retrieve BGP route information from their backbone servers. In particular, SdV operates a <a href="http://bgpmap.sdv.fr/">graphical traceroute tool</a> which lets you visualize all the routes to a certain IP available in their border gateways&#39; routing tables. Here&#39;s an example output for <a href="https://developers.google.com/speed/public-dns">8.8.8.8</a>, which is Google&#39;s public DNS project.</p>
<p><img loading="lazy" src="bgp-traceroute.gif" alt="bgp map to google dns"></p>
<p>The red arrows signify the best path, the one that packets would actually follow in the network. As you can see, there is more than one way to reach the destination; Google is part of <a href="https://www.franceix.net/en/">France-IX</a>, which SdV is also a member of. The purple rectangles represent border routers within SdV&#39;s own network; they aren&#39;t shown for other networks since they are normally obscured from public view.</p>
<aside>

<p>The way <code>traceroute</code> works is really fascinating. Ever wonder how it figures out the route a packet takes between point A and point B when the Internet Protocol suite seemingly provides no such functionality? The answer is remarkably clever. It starts by sending a packet to the destination with a TTL of 1. This packet will travel down one hop along the route before the router sees that the TTL has reached zero, and sends an ICMP error message to the original sender. This reveals the first router along the path; a packet of TTL 2 will reveal the second router, and so on, until the destination IP is reached. </p>
</aside>

<h2 id="the-politics-of-peering">The Politics of Peering <a class="section-link" href="#the-politics-of-peering">&sect;</a></h2><p>In the words of <a href="https://blog.thelifeofkenneth.com/">Kenneth Finnegan</a>, regarding BGP peering:</p>
<blockquote>
<p>This is obviously where human networking becomes exceedingly important in computer networking.</p>
</blockquote>
<p>Broadly speaking, inter-AS connections can be categorized into two types:</p>
<ul>
<li><strong>Peering</strong> is an agreement between two ASes to share traffic, usually out of mutual benefit. Most commonly, &quot;peering&quot; refers to <em>settlement-free peering</em>, so no party is paying for the connection.</li>
<li><strong>Transit</strong> is a paid service where an AS with a highly interconnected global network offers to peer with another AS in exchange for a fee.</li>
</ul>
<p>Note that peering and transit are the same thing from a technical standpoint. Also, <em>BGP peering</em> simply refers to the existence of a connection between two ASes. It doesn&#39;t necessarily mean that no settlement is involved. </p>
<p>Another staple of backbone routing is the <a href="https://en.wikipedia.org/wiki/Internet_exchange_point">Internet Exchange Point</a> (IXP). IXPs are essentially a series of interconnected switches, usually managed by a non-profit organization, that allow many ASes to peer with each other without a huge number of cross-connections. </p>
<figure style="max-width: 3888px">
    <img loading="lazy" src="internet-exchange.jpg" alt="internet exchange cables">
    <figcaption>One of many switches which make up <a href="https://en.wikipedia.org/wiki/Amsterdam_Internet_Exchange">AMS-IX</a>, one fo the world's largest Internet exchanges. <a href="https://en.wikipedia.org/wiki/File:AMS-IX_optical_patch_panel.jpg">Photo</a> by Fabienne Serriere / <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">CC BY-SA</a>.</figcaption>
</figure>

<p>IXPs are a pretty great thing for a number of reasons. They provide a way to peer with numerous other ASes, reducing latency for everyone, while avoiding the large number of physical connections that would be necessary to reach the same level of connectedness that would be necessary otherwise.</p>
<p><img loading="lazy" src="peering.png" alt="peering diagram"></p>
<p>If you are interested in internet exchanges, I encourage you to checkout the <a href="https://fcix.net/">Fremont Cabal Internet Exchange</a>, a burgeoning IXP based out of Fremont, California (which is also my hometown!) The <a href="https://blog.thelifeofkenneth.com/2018/04/creating-internet-exchange-for-even.html">blogpost</a> about its creation is as informative as it is humorous.</p>
<h2 id="not-all-ases-are-made-equal">Not All ASes Are Made Equal <a class="section-link" href="#not-all-ases-are-made-equal">&sect;</a></h2><p>Some ASes are more connected than others. You may hear talk about so-called &quot;tier 1&quot; networks; generally speaking, tier 1 networks are ASes which don&#39;t need to pay for transit to reach any other AS on the Internet. They are <a href="https://en.wikipedia.org/wiki/Tier_1_network#List_of_Tier_1_networks">few and far between</a>, mostly because the Internet has grown to the point where it&#39;s very hard to reach <em>every</em> network without at least paying somewhere along the way.</p>
<p>Historically, many tier 1 networks were primarily located in the US, resulting in a lot of traffic flowing through US networks. This trend has <a href="https://www.nytimes.com/2008/08/30/business/30pipes.html?pagewanted=all">slowly eroded</a>, however, as Internet infrastructure becomes more advanced in other countries. Conversely, the NSA <a href="https://tcf.org/content/report/surveillance-without-borders-the-traffic-shaping-loophole-and-why-it-matters/">diverts American traffic</a> offshore so that it can legally perform surveillance.</p>
<p>Tier 1 networks are followed by tier 2 (pay for transit to reach some ASes) and tier 3 (exclusively pay for transit). </p>
<h2 id="bgp-mishaps">BGP Mishaps <a class="section-link" href="#bgp-mishaps">&sect;</a></h2><p>BGP has a history of high-profile screwups with cascading consequences, often taking down large segments of the Internet. Just last year, Facebook suffered a <a href="https://engineering.fb.com/2021/10/05/networking-traffic/outage-details/">total outage</a> due to what later turned out to be a BGP misconfiguration. BGP is in fact rather vulnerable to <a href="https://en.wikipedia.org/wiki/BGP_hijacking">hijacking attacks</a>, since any AS could announce a high-priority bogus route that could make affected network prefixes unroutable. <a href="https://en.wikipedia.org/wiki/Resource_Public_Key_Infrastructure">Resource Public Key Infrastructure</a> (RPKI) was created to resolve this problem, but adoption still remains a challenge. Here are some notable BGP incidents:</p>
<ul>
<li>February 2008: Pakistan Telecom (AS17557) <a href="https://www.ripe.net/publications/news/industry-developments/youtube-hijacking-a-ripe-ncc-ris-case-study">brought YouTube offline</a> by broadcasting prefixes for YouTube IPs in a severely misguided attempt to block the website.</li>
<li>August 2014: Canadian hackers repeatedly <a href="https://www.secureworks.com/research/bgp-hijacking-for-cryptocurrency-profit">redirected traffic</a> through their servers to steal cryptocurrency miners&#39; earnings. </li>
<li>December 2017: A Russian autonomous system (AS39523) <a href="https://bgpmon.net/popular-destinations-rerouted-to-russia/">announced routes</a> for prefixes normally leading to services run by Apple, Facebook, Microsoft, and others. This came after years of no route announcements.</li>
</ul>
<p>BGP has faced other issues than hijacking, though. Though not a problem with the protocol itself, historically many border routers had a limit of 512K routes, so when the BGP routing table suddenly grew to above that threshold on August 12, 2014, numerous Internet companies <a href="https://www.theguardian.com/technology/2014/aug/14/internet-infrastructure-needs-updating-more-blackouts-will-happen">faced outage</a> as BGP routing slowed to a crawl.</p>
<h1 id="multicast-and-anycast">Multicast and Anycast <a class="section-link" href="#multicast-and-anycast">&sect;</a></h1><p>So far, we&#39;ve only discussed <em>unicast</em> traffic, where packets are routed from one host to the next. However, IP also supports alternative routing schemes.</p>
<p><strong>Anycast routing</strong> allows numerous geographically separate hosts to operate under the same IP. When you send a packet to an anycast address, it is delivered to the &quot;closest&quot; host as seen by the core routers along the path. This allows traffic to be automatically distributed between several servers, potentially reducing latency and increasing throughput. However, because IP is stateless, packets addressed to anycast packets are not guaranteed to arrive at the same host, which could potentially disrupt stateful protocols like TCP. As a result, anycast is most popular for scaling protocols where transactions are short-lived (and thus the odds of a connection being disrupted are low). In particular, many DNS services (such as all of the <a href="https://en.wikipedia.org/wiki/Root_name_server">root name servers</a> and many popular DNS resolvers) are scaled using anycast.</p>
<p><strong>Multicast routing</strong> allows packets to be delivered to any hosts which have indicated that they are willing to participate in a given <em>multicast group</em>, managed by the <a href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol">Internet Group Management Protocol</a> (IGMP). All multicast packets have destination addresses in the 224.0.0.0/4 range as <a href="https://datatracker.ietf.org/doc/html/rfc5771">reserved</a> by IANA. Senders of multicast periodically use IGMP to query the network for participants; hosts interested in receiving multicast packets on a specific address join that group by responding to the query. </p>
<p>One of the most common protocols that uses multicast routing is <a href="https://en.wikipedia.org/wiki/Multicast_DNS">multicast DNS</a> (mDNS), which is essentially a variant of DNS that works over multicast. It is often used to discover devices on the LAN such as printers.</p>
<p><img loading="lazy" src="mdns-capture.png" alt="mdns traffic on my LAN"></p>
<p><em>mDNS traffic on my LAN. I&#39;m pretty sure it&#39;s from my printer.</em></p>
<p>Unlike anycast, multicast generally doesn&#39;t work outside of local networks; most providers do not route multicast traffic through their networks because it can potentially be used to amplify a <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">denial of service</a> attack, flooding hosts&#39; networks with packets and preventing users from accessing their services.</p>
<h1 id="ipv6">IPv6 <a class="section-link" href="#ipv6">&sect;</a></h1><p>IPv6 is the successor of IPv4, created to solve various problems with the original Internet protocol (beyond just IPv4 exhaustion). However, it still fulfills the same role as IPv4, and as a result most protocols built on top of IP work fine with both protocols (though some modifications may be necessary to work with the longer addresses).</p>
<p>One of IPv6&#39;s most attractive features is its longer address length (128 bits), meaning that every device can have its own IP address instead of resorting to ugly solutions such as NAT. This restores the end-to-end principle on the Internet. In addition, IPv6 packet headers have been considerably simplified, allowing for faster processing by routers. One way this was accomplished was by removing the concept of fragmentation from IPv6; instead, the sender is responsible for discovering the maximum MTU that a given route can accept (which is guaranteed to be at least <a href="https://datatracker.ietf.org/doc/html/rfc2460">1280 bytes</a>).</p>
<p>IPv6 also supports multicast traffic; in fact, broadcast is entirely supplanted by multicast. There are special addresses used for routing packets to all nodes or routers on a local network, but these are all implemented using <a href="https://datatracker.ietf.org/doc/html/rfc3810">Multicast Listener Discover</a>, IPv6&#39;s replacement for IGMP.</p>
<h1 id="epilogue">Epilogue <a class="section-link" href="#epilogue">&sect;</a></h1><p>This post is very much still a work in progress. As you may have noticed, the IPv6 section is rather sparse. When I can find time, I plan on writing more and revising various parts of the article (which was written in quite a hurry, as you may have noticed).</p>
<h1 id="further-reading--references">Further Reading / References <a class="section-link" href="#further-reading--references">&sect;</a></h1><ul>
<li><a href="https://www.cloudflare.com/learning/security/glossary/what-is-bgp/">What is BGP? (Cloudflare)</a></li>
<li><a href="https://www.cloudflare.com/learning/cdn/glossary/internet-exchange-point-ixp/">What is an Internet exchange point? (Cloudflare)</a></li>
<li><a href="https://blog.thelifeofkenneth.com/2017/11/creating-autonomous-system-for-fun-and.html">Creating an Autonomous System for Fun and Profit (The Life of Kenneth)</a></li>
<li><a href="https://blog.thelifeofkenneth.com/2018/04/creating-internet-exchange-for-even.html">Creating an Internet Exchange for Even More Fun and Less Profit (The Life of Kenneth)</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791: IPv4 (IETF)</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8200">RFC 8200: IPv6 (IETF)</a></li>
</ul>
<img id="img-view" style="display: none"><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" label="blog-post-comments" theme="preferred-color-scheme" issue-number="10"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog/tree/main/public/blogposts/internet-explained">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>