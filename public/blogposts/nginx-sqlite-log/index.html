<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Logging Requests with SQLite and Nginx</title><meta property="og:title" content="Logging Requests with SQLite and Nginx"><meta property="og:type" content="website"><meta property="og:description" content="A guide on how to configure Nginx to store requests in an SQLite table."><meta name="description" content="A guide on how to configure Nginx to store requests in an SQLite table."><link rel="stylesheet" href="/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/blogposts/nginx-sqlite-log"></head><body><header><a href="/"><img src="/images/banner.png" alt="blog banner"></a></header><main><p id="date" class="date">August 21, 2022</p><h1 style="margin-top: 0">Logging Requests with SQLite and Nginx</h1><nav><div id="contents"><p>Table of Contents</p><a href="#getting-log-lines-from-nginx"><p>Getting Log Lines from NGINX</p></a><a href="#storing-requests"><p>Storing Requests</p></a><a href="#putting-it-all-together"><p>Putting It All Together</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p>In case you haven&#39;t realized, I am a big fan of SQLite. In my opinion, the balance between convenience and flexibility that it offers is simply not matched by any other database out there. Since most of my projects are small and will likely remain small, I often find myself gravitating towards SQLite. Thus, one day I landed upon the idea of getting Nginx to store requests within an SQLite database instead of logging them to a text file, for two reasons:</p>
<ul>
<li>I am super bad at not accidentally deleting things, and having one file is a whole lot easier than dozens of logs scattered all over the place.</li>
<li>Consolidating all log messages into one place makes it a lot easier to perform analysis on them, and also makes them readily consumable by other applications.</li>
</ul>
<p>Googling revealed multiple solutions that enabled me to accomplish my goals to great degree of customizability. But I didn&#39;t feel like using any of them. For no reason. Some bizarre, neurotic, obsessive-compulsive tendency within me screamed to waste time reinventing the wheel instead of taking the easy way out, and the rest of my brain simply caved to its siren call. (It didn&#39;t help that Twitter wasn&#39;t loading on my computer at the time.)</p>
<p>Well, my sleep schedule was bound to deterioriate on its own anyways. Let&#39;s get to work.</p>
<h1 id="getting-log-lines-from-nginx">Getting Log Lines from NGINX <a class="section-link" href="#getting-log-lines-from-nginx">&sect;</a></h1><p>Nginx supports the <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> protocol, so our approach will be to configure Nginx to deliver log messages to a daemon of our own design via syslog.</p>
<p>syslog is a pretty simple protocol, if we choose to ignore the complicated parts. We can get Nginx to send a UDP packet to some server for every request that it receives, parse the packet to extract the request data, and save it to a database. The fact that UDP is used for transport is not a problem if the two processes are running on the same machine.</p>
<p>Let&#39;s do a little experimenting before we start coding. We can enable logging to syslog by adding this to our Nginx configuration:</p>
<pre><code class="hljs">access_log syslog:server=localhost:1234,facility=local7,tag=nginx,severity=info;</code></pre><p>For now, let&#39;s simply log the received packets to stdout with ncat. Here&#39;s what a typical log message looks like:</p>
<pre><code class="hljs">&lt;190&gt;Aug 21 00:06:11 bithole.dev nginx: 127.0.0.1 - - [21/Aug/2022:00:06:11 -0700] &quot;GET / HTTP/2.0&quot; 200 4310 &quot;-&quot; &quot;curl/7.68.0&quot;</code></pre><p>Outputting JSON log messages is probably a good idea because it will make the inputs more amenable for consumption with NodeJS. We can accomplish that with a custom log format:</p>
<pre><code class="hljs">log_format json_log escape=json
    &#x27;{&#x27;
        &#x27;&quot;timestamp&quot;: $msec,&#x27;
        &#x27;&quot;requestLen&quot;: $request_length,&#x27;
        &#x27;&quot;status&quot;: $status,&#x27;
        &#x27;&quot;remoteAddr&quot;: &quot;$remote_addr&quot;,&#x27;
        &#x27;&quot;requestMethod&quot;: &quot;$request_method&quot;,&#x27;
        &#x27;&quot;requestUri&quot;: &quot;$request_uri&quot;,&#x27;
        &#x27;&quot;protocol&quot;: &quot;$server_protocol&quot;,&#x27;
        &#x27;&quot;referrer&quot;: &quot;$http_referrer&quot;,&#x27;
        &#x27;&quot;userAgent&quot;: &quot;$http_user_agent&quot;,&#x27;
        &#x27;&quot;host&quot;: &quot;$host&quot;&#x27;
    &#x27;}&#x27;;</code></pre><p>Now, we just need to tell Nginx to use the <code>json_log</code> format, which gets our log lines looking like this:</p>
<pre><code class="hljs">&lt;190&gt;Aug 21 11:11:16 bithole.dev nginx: {&quot;timestamp&quot;: 1661105476.291,&quot;requestLen&quot;: 28,&quot;status&quot;: 200,&quot;remoteAddr&quot;: &quot;127.0.0.1&quot;,&quot;requestMethod&quot;: &quot;GET&quot;,&quot;requestUri&quot;: &quot;/&quot;,&quot;protocol&quot;: &quot;HTTP/2.0&quot;,&quot;referrer&quot;: &quot;&quot;,&quot;userAgent&quot;: &quot;curl/7.68.0&quot;,&quot;host&quot;: &quot;bithole.dev&quot;}</code></pre><h1 id="storing-requests">Storing Requests <a class="section-link" href="#storing-requests">&sect;</a></h1><p>All we have left to do is actually implement the server. In theory, this is a trivial task, but, well&hellip; it was about 1 AM, so&hellip;</p>
<figure style="max-width: 373px">
    <img src="commits.png" alt="commit messages on 21 Aug 2022">
    <figcaption>The commits messages say it all.</figcaption>
</figure>

<p>The code is fairly simple, though we do have to take some measures to ensure that it stays performant. Specifically, we want to avoid SQLite&#39;s default behavior of beginning a new transaction for every single row inserted into the database. The impact that this has on INSERT throughput is simply <em>astounding</em>; while working on the <a href="/blogposts/mc-census/">Minecraft server census</a> blogpost, consoldating INSERTs into a single transaction increased the rate by over 1,000x. Thus, I was mindful of making the same mistake again. I ended up grouping all requests over a one-second period into a single transaction.</p>
<p>Here is the distilled version of the final server code:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> server = dgram.<span class="hljs-title function_">createSocket</span>(<span class="hljs-string">&quot;udp6&quot;</span>);

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;listening&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Listening on port &quot;</span> + process.<span class="hljs-property">env</span>.<span class="hljs-property">SYSLOG_PORT</span>));

<span class="hljs-comment">// periodically commit requests to DB</span>
<span class="hljs-keyword">let</span> inTransaction = <span class="hljs-literal">false</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span>(inTransaction) {
        db.<span class="hljs-title function_">prepare</span>(<span class="hljs-string">&quot;COMMIT&quot;</span>).<span class="hljs-title function_">run</span>();
        inTransaction = <span class="hljs-literal">false</span>;
    }
}, <span class="hljs-variable constant_">TRANSACTION_INTERVAL</span>);

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> {
    
    <span class="hljs-keyword">const</span> str = msg.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;utf-8&quot;</span>);
    <span class="hljs-keyword">const</span> object = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str.<span class="hljs-title function_">slice</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;{&#x27;</span>)));

    <span class="hljs-keyword">if</span>(!inTransaction) {
        db.<span class="hljs-title function_">prepare</span>(<span class="hljs-string">&quot;BEGIN&quot;</span>).<span class="hljs-title function_">run</span>();
        inTransaction = <span class="hljs-literal">true</span>;
    }

    insertStmt.<span class="hljs-title function_">run</span>(object);

});

server.<span class="hljs-title function_">bind</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">SYSLOG_PORT</span>);</code></pre><h1 id="putting-it-all-together">Putting It All Together <a class="section-link" href="#putting-it-all-together">&sect;</a></h1><p>If you are content with using my shitty code, it is available on GitHub as <a href="https://github.com/adrian154/syslog2sqlite">syslog2sqlite</a>. There is also a Docker image available on Docker Hub as <a href="https://hub.docker.com/r/adrian154/syslog2sqlite">adrian154/syslog2sqlite</a>. However, you are probably better off using existing syslog tooling like syslog-ng.</p>
<p>That&#39;s all, folks!</p>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="/rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>