<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Transport Layer Security (5/6)</title><meta property="og:title" content="Transport Layer Security (5/6)"><meta property="og:type" content="website"><meta property="og:description" content="In this article, we examine the gory details of a TLS session, down to every byte exchanged. If you've ever wondered how the Web is secured, this one's for you."><meta name="description" content="In this article, we examine the gory details of a TLS session, down to every byte exchanged. If you've ever wondered how the Web is secured, this one's for you."><link rel="stylesheet" href="static/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="static/stylesheets/main.css"><link rel="stylesheet" href="static/stylesheets/packetview.css"><script defer src="static/scripts/packetview.js"></script><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="static/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="static/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/tls.html"></head><body><header><a href="/"><img src="static/images/banner.jpg" alt="blog banner"></a></header><main><noscript><p style="color: #ff0000">Warning: If you are seeing this message, JS isn't supported; unfortunately, since this page relies on JS to dynamically generate content, parts of the page may be missing or brutally disfigured.</p></noscript><p id="date" class="date">February 25, 2022</p><h1 style="margin-top: 0">Transport Layer Security (5/6)</h1><nav><div id="contents"><p>Table of Contents</p><a href="#conceptual-overview"><p>Conceptual Overview</p></a><a href="#confidentiality"><p>Confidentiality</p></a><a href="#authenticity"><p>Authenticity</p></a><a href="#integrity"><p>Integrity</p></a><a href="#client-handshake-key-generation"><p>Client Handshake Key Generation</p></a><a href="#c--s-client-hello"><p>C → S: Client Hello</p></a><a href="#server-handshake-key-generation"><p>Server Handshake Key Generation</p></a><a href="#s--c-server-hello"><p>S → C: Server Hello</p></a><a href="#handshake-key-exchange"><p>Handshake Key Exchange</p></a><a href="#perfect-forward-secrecy"><p>Perfect Forward Secrecy</p></a><a href="#s--c-change-cipher-spec"><p>S → C: Change Cipher Spec</p></a><a href="#s--c-encrypted-extensions"><p>S → C: Encrypted Extensions</p></a><a href="#s--c-certificate"><p>S → C: Certificate</p></a><a href="#s--c-certificate-verify"><p>S → C: Certificate Verify</p></a><a href="#s--c-finished"><p>S → C: Finished</p></a><a href="#c--s-change-cipher-spec"><p>C → S: Change Cipher Spec</p></a><a href="#c--s-finished"><p>C → S: Finished</p></a><a href="#s--c-new-session-ticket"><p>S → C: New Session Ticket</p></a><a href="#application-key-calculation"><p>Application Key Calculation</p></a><a href="#s--c-application-data"><p>S → C: Application Data</p></a><a href="#epilogue"><p>Epilogue</p></a><a href="#behind-the-scenes"><p>Behind the Scenes</p></a><a href="#further-reading"><p>Further Reading</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p><a href="internet-series.html"><em>This post is part of a series.</em></a></p>
<p>The Internet is, by default, not secure. In TCP and below, everything is transferred in plaintext; an attacker could snoop on your communications or, worse, masquerade as the person you think you&#39;re talking to. Yet today, most users don&#39;t have to worry about those kinds of attacks. Why not? The answer is the <strong>Transport Layer Security</strong> protocol, which transparently secures much of the modern Web. Strap in, because we&#39;re about to learn some cryptography.</p>
<h1 id="conceptual-overview">Conceptual Overview <a class="section-link" href="#conceptual-overview">&sect;</a></h1><p>TLS aims to create a secure channel with three properties: <strong>confidentiality</strong>, <strong>authenticity</strong>, and <strong>integrity</strong>. These three properties go hand in hand, but each one has a distinct meaning. </p>
<h2 id="confidentiality">Confidentiality <a class="section-link" href="#confidentiality">&sect;</a></h2><p>It&#39;s pretty easy to see why confidentiality is important: nobody wants a third party to be able to read your communications. The solution is to encrypt your data with a cipher, an algorithm which accepts a plaintext and a key and produces a ciphertext, such that it is easy to retrieve the plaintext if you have the key, but virtually impossible without it. When a cipher uses the same key to encrypt and decrypt data, it is called a <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric cipher</a>.</p>
<p>Symmetric ciphers are great because they&#39;re usually very fast and very secure, but they do have one weakness: key exchange. The two communicating parties need to figure out a way to share a secret key without the possibility of anyone else obtaining it. This creates a bit of a chicken-and-egg problem; after all, they can&#39;t establish a private means of communication without negotiating a key first, which just brings us back to square one. To solve this problem, we need to get a little more clever.</p>
<p>Enter the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman Key Exchange</a>. It enables a client and a server to generate the same secret value while only exchanging publicly knowable data, which sounds impossible until you take a look at how it works. Here&#39;s a diagram that explains the steps of Diffie-Hellman key exchange using colors of paint as a stand-in for cryptographic keys.</p>
<p><img src="resources/tls/DHKE-paint-analogy.png" alt="DHKE diagram using paint analogy"></p>
<br>

<p>We can make this model a little more rigorous by replacing the paints with variables. Suppose <code>C</code> is some common value that both Alice and Bob know. The paint-mixing can be modeled as an operation which we will call <code>*</code>, with the following properties:</p>
<ul>
<li>It is easy to compute <code>x * y</code>, but even if the value of <code>x</code> or <code>y</code> is known, it should be very difficult to retrieve the operands from the result of the operation. Examples of such operations will be discussed later.</li>
<li>The operation must be associative, i.e. <code>(x * y) * z</code> = <code>(x * z) * y</code>.</li>
</ul>
<p>(Don&#39;t let the notation confuse you. <code>*</code> does <em>not</em> represent regular multiplication, which wouldn&#39;t work for this process since it doesn&#39;t fulfill our first requirement.)</p>
<p>Now, we&#39;re ready to do the key exchange. Alice generates a random secret <code>A</code>, and Bob generates a random secret <code>B</code>. Alice sends Bob <code>A * C</code> and Bob sends Alice <code>B * C</code>. Now, Alice can compute <code>A * (B * C)</code> and Bob can compute <code>B * (A * C)</code>. Because the operation is associative, Alice and Bob arrive at the same value, which they can now use as the key to a symmetric cipher.</p>
<p>However, if an attacker could observe the key exchange between Alice and Bob, they would only obtain <code>A * C</code> and <code>B * C</code>. The attacker probably knows <code>C</code>, but because reversing the operation is hard, the attacker cannot calculate <code>A</code> or <code>B</code>, and thus cannot determine the shared secret.</p>
<aside>

<p>Diffie-Hellman key exchange is where mathematical concepts such as <a href="https://en.wikipedia.org/wiki/Group_(mathematics)">groups</a> become very useful. A group is a structure consisting of a set of elements and an operation which accepts two elements and produces one element. This operation must be associative (among other requirements).</p>
<p>The characteristics of certain groups make them useful for key exchange, and cryptography in general. For example, <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> uses a <a href="https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n">multiplicative group of integers modulo <em>n</em></a> where the modulus is a large semiprime. RSA&#39;s security relies on the fact that there are currently no effective algorithms for <a href="https://en.wikipedia.org/wiki/Integer_factorization">factoring large integers</a>; hence, reversing the group operation remains difficult. Incidentally, this is why quantum computers spell the end for RSA, since they are capable of factoring integers in <a href="https://en.wikipedia.org/wiki/Shor%27s_algorithm">O((log n)^3)</a>. Thankfully, there are no quantum computers fast enough to pose a threat to RSA... yet.</p>
<p>Today, cryptosystems based on <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">elliptic curve groups</a> have become popular since they offer similar security to RSA, but with much smaller and thus more convenient keys. These constructions make use of a property which certain elliptic curve groups possess: if a starting point <em>P</em> is added to itself <em>n</em> times, it is very difficult to determine <em>n</em> even if both the starting point and the ending point are known. This is known as the elliptic curve discrete logarithm problem, and so far very little progress has been made in the way of attacking it.</p>
<p>I&#39;m really terrible at explaining group theory, so if you want to learn more check out this <a href="https://math.mit.edu/~jwellens/Group%20Theory%20Forum.pdf">short introduction</a>.</p>
</aside>

<h2 id="authenticity">Authenticity <a class="section-link" href="#authenticity">&sect;</a></h2><p>Confidentiality is worthless if you can&#39;t ensure that the person on the other end of the line is who you actually <em>intend</em> to talk to. One of TLS&#39;s jobs is to help the server prove its identity. This is accomplished with the help of digital signatures.</p>
<p>Digital signatures are a form of <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public key cryptography</a>, so the client first has to generate a keypair. This is usually done by creating a private key from random data, and then deriving a public key using a process specific to the signature scheme. The public key serves as the cryptographic identity of the client, and it can be distributed safely without compromising the private key.</p>
<p>To create a digital signature, the client uses the signing algorithm to convert their private key and a piece of data into a short output known as a signature. Signatures are useful since they have the following properties:</p>
<ul>
<li>Anyone can prove that a signature is valid using just the public key and the data.</li>
<li>The signature won&#39;t validate if the data doesn&#39;t match what was originally signed.</li>
<li>No one can create a signature without possessing the private key.</li>
</ul>
<p>One can imagine a scheme involving a trusted third party that leverages the power of digital signatures to associate a public key with a real-world identity. Suppose Bob wants to send a message to Alice, but he wants to assure Alice that the message was actually sent by him and not an impostor. Sure, he could sign the message, but what good is that if Alice doesn&#39;t know his public key? This becomes the goal of authentication: establishing a relationship between a useful identity and a public key.</p>
<p>Here&#39;s how TLS approaches this problem. Bob is friends with Carol, who&#39;s so famous that everybody knows her public key. Bob asks Carol to sign the following statement:</p>
<blockquote>
<p>Bob&#39;s public key is 123456789.</p>
</blockquote>
<p>Carol makes sure that the person she&#39;s talking to is actually Bob, and signs Bob&#39;s statement (which is known as a <em>certificate</em> in cryptography). Now, Bob can send Alice his certificate, allowing Alice to be sure of Bob&#39;s public key. Now Bob can sign all his messages, preventing an attacker from tricking Alice into accepting a message that isn&#39;t from Bob thanks to their inability to craft a valid signature.</p>
<p>This, in essence, is how TLS performs authentication. Carol represents a group of organizations known as <a href="https://en.wikipedia.org/wiki/Certificate_authority">certificate authorities</a>, whose public keys are hardcoded into web browsers. Certificates on the web generally don&#39;t link a human name to a public key; instead, the &quot;useful identity&quot; they try to anchor is usually a domain name. Furthermore, the CA may not directly sign a website&#39;s certificate. Instead, they may sign the certificate for an <em>intermediate</em> keypair, which does the task of actually signing end user certificates. This sequence can extend for as many signatures as necessary, creating a <strong>chain of trust</strong>.</p>
<figure style="max-width: 1280px">
    <img src="resources/tls/certificate-chain-of-trust.png" alt="chain of trust diagram">
    <figcaption>A rough diagram showing how a verifiable chain of trust is created using digital signatures. <a href="https://en.wikipedia.org/wiki/File:Chain_Of_Trust.svg">Image</a> by Yukhih / <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA</a>.</figcaption>
</figure>

<p>You can see this at play for pretty much any website you visit. If you&#39;re on Chrome, simply click the padlock button next to the address bar in your browser, and you&#39;ll see the option to view the website&#39;s certification path. Here&#39;s what you would probably see for this page:</p>
<p><img src="resources/tls/windows-cert-view.png" alt="picture of the ssl cert for this site"></p>
<p>During the TLS handshake process, all three of these certificates were sent from my server to your browser. The first certificate (bithole.dev) contains my server&#39;s public key, as well as a reference to <code>R3</code>&#39;s public key and a signature made with that public key. In turn, R3 is signed by ISRG Root X1, whose fingerprint is hardcoded into your browser as one of several trusted <strong>root certificates</strong>. Your browser can follow this chain of signatures and verify that each certificate is valid.</p>
<p>Simply receiving a valid certificate doesn&#39;t prevent man-in-the-middle attacks, though. Certificates are public knowledge; my webserver has to actually prove ownership of the corresponding private key somehow. To solve this, TLS makes the server sign the hash of all the messages sent before certificate verification. This assures the client that at no point during the handshake did an attacker mingle in their communications.</p>
<aside>

<p>In this context, a hash refers to a <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a>, which essentially converts variable-length data into a fixed-length digest. Cryptographic hashes also have the following properties:</p>
<ul>
<li>It is very difficult to determine the input based on the output.</li>
<li>Changing the input even slightly results in a totally different output.</li>
<li>It is very difficult to find two inputs which result in the same hash (a <a href="https://en.wikipedia.org/wiki/Hash_collision">collision</a>).</li>
</ul>
<p>Examples of cryptographic hashes include the <a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">Secure Hash Algorithm</a> family, which includes hashes like SHA-256. If we hash the string &quot;cookie&quot; with SHA-256, we get this value:</p>
<pre><code class="hljs">d7e83e28a04b537e64424546b14caf9b67bad2f28dabce68116e0d372319fa00</code></pre><p>However, if I hash &quot;cookies&quot;, this is the output:</p>
<pre><code class="hljs">2f0030c535193fc164e4e2b5371e8e676510cf0a64b2689d9aba6533e6ddea82</code></pre><p>As you can see, changing a single character ends up producing two distinct hashes with seemingly no relationship. The characteristics of hash functions make them very useful for cryptography, which we will see later.</p>
</aside>

<p><em>If a CA issued a certificate to a hacker, wouldn&#39;t my computer blindly trust it?</em> you might ask. The answer is yes, unfortunately. That&#39;s why there are so few root CAs, which are audited frequently. This is also why most sites&#39; certificates aren&#39;t directly signed by the root certificate. The root certificate is kept offline for maximum security, and all signing is done with an intermediate signed by the root instead. In the event that the intermediate certificate is compromised, things are <em>bad</em> but not <em>really bad</em>; the CA can simply issue a new intermediate instead of trying to get every user to adopt a new root certificate.</p>
<p>In theory, a trusted CA should ony issue certificates to people who can actually prove ownership of a domain&mdash;for example, Let&#39;s Encrypt checks if a specific DNS record has been deployed for verification&mdash;but ultimately, you cannot be 100% sure that these entities will not try to attack your TLS connections. In response, some organizations choose to run their own internal CA and issue their own certificates. This removes the dependence on an external entity, but requires that all users manually add the CA&#39;s root certificate to their computer&#39;s list of trusted certificates. As a result, it&#39;s only really feasible to secure closed systems like enterprise environments this way.</p>
<p>Here&#39;s a conversational illustration of all these concepts at play in a TLS handshake.</p>
<div class="conversation">
    <div class="conversation-header">
        <div><b>Client</b></div>
        <div><b>Server</b></div>
    </div>
    <div>
        <div class="client-says">Hello, here are the cipher suites I support, as well as a public key I have generated for this session.</div><div></div>
    </div>
    <div>
        <div></div><div class="server-says">Let's use &lt;...&gt; as the cipher suite for this connection. Here is the public key I have generated for this session.</div>
    </div>
    <div>
        <div class="conversation-center"><i>Both sides calculate the shared secret.</i></div>
    </div>
    <div>
        <div></div><div class="server-says">Here is my certificate. It is signed by R3, which is signed by ISRG Root X1 (which is hopefully in your trusted certificates list). In addition, here is a digital signature of all the messages I've sent so far, which you can verify using the public key contained within my certificate.</div>
    </div>
    <div>
        <div class="client-says">Your certificate appears valid, and so does the signature. I am now convinced of your identity and will start sending encrypted data.</div><div></div>
    </div>
</div>

<h2 id="integrity">Integrity <a class="section-link" href="#integrity">&sect;</a></h2><p>Even if you have authenticated with a server and established a secure channel, there still remains a problem: an attacker who controls the network between you and your destination can still modify the ciphertext messages being exchanged. The attacker doesn&#39;t need to be able to decipher the messages; for example, simply resending the same ciphertext could result in a request being repeated if the proper protections aren&#39;t in place. This is known as a <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attack</a>.</p>
<p>A system vulnerable to such an attack would be unacceptable for many applications. Ideally, we also want some strong cryptographic guarantee that the message wasn&#39;t tampered with in transit. TLS accomplishes this using <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption</a>.</p>
<p>In TLS 1.3, integrity is handled by only using ciphers which include <strong>authenticated encryption with associated data (AEAD)</strong>. When encrypting data using an AEAD cipher, an authentication tag is produced in addition to the ciphertext. The auth tag allows clients to verify that the plaintext matches what was originally encrypted. In addition, the auth tag can also guarantee the validity of some associated data not included within the ciphertext, the <em>associated data</em>. All of this is done without leaking any information about the encrypted data itself.</p>
<p>With all of that being said, let&#39;s actually examine a recorded TLS session and see how all of these cryptographic concepts are implemented.</p>
<h1 id="client-handshake-key-generation">Client Handshake Key Generation <a class="section-link" href="#client-handshake-key-generation">&sect;</a></h1><p>Before the client even begins the handshake, it first generates an <a href="https://cr.yp.to/ecdh.html">x25519</a> keypair for use in key exchange later down the road. The private key is simply created by drawing 32 bytes of random data from an unpredictable source. Here is the client&#39;s private key, which is never sent over the network:</p>
<pre><code class="hljs">186b7a9daf3855fa090bf29a69391dc1ee788393f2dba58a23cab0f6b96d6355</code></pre><p>The public key is derived by multiplying the fixed starting point (x = 9) by the private key. The elliptic-curve discrete logarithm problem prevents attackers from calculating the private key from the starting point and the public key. This is the public key, which you will see later in the exchange:</p>
<pre><code class="hljs">4b65e1788c1999350d0a44f50646a75c392584735d96d6d0b35b61c2f9375931</code></pre><h1 id="c--s-client-hello">C → S: Client Hello <a class="section-link" href="#c--s-client-hello">&sect;</a></h1><p>TLS handshakes begin with the Client Hello message, where the client declares its capabilities to the server. Most importantly, it lists the TLS versions it understands as well as a list of supported ciphers for encryption. It also sends its public key.</p>
<p><strong>Guide</strong>: Click on a section of the packet to see a description of its significance. Click the hex preview on the left to return to the top. Try enabling &quot;show all&quot; if you want to read all the section descriptions.</p>
<div class="client packet">
<div class="segment" data-hex="1603010158" data-name="Record Header">

<p>Messages in a TLS session are exchanged in the form of <em>records</em>. All records begin with a <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-B.1">header</a> that gives information about the content of the record.</p>
<ul>
<li><code>16</code>: record type (22 for handshake)</li>
<li><code>03 01</code>: protocol version (TLS 1.0 for backwards compatibility)</li>
<li><code>01 58</code>: length of payload (344 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="01000154" data-name="Handshake Header">

<p>The <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-B.3">Client Hello</a> message begins with a four-byte header describing the contained data.</p>
<ul>
<li><code>01</code>: message type (1 for ClientHello)</li>
<li><code>00 01 54</code>: message length (340 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="0303" data-name="ClientHello Version">

<p>In TLS 1.2 and below, this field indicated the highest version supported by the client. However, using this field for version negotiation has been deprecated in favor of the <code>supported_versions</code> extension, so in TLS 1.3 this field is set to <code>0x0303</code> (TLS 1.2) to support older servers.</p>
</div>
<div class="segment" data-hex="035735d60c9512c61134349e99999105922738a7ee2110b0692817ec961a21dd" data-name="Random">

<p>The client shares 32 bytes of randomness which help secure the handshake process, as we will see later.</p>
</div>
<div class="segment" data-hex="20cce0a325341c9485b11e794e263fe3c3399204aaec8dc73eb996cd79f973d1b2" data-name="Legacy Session ID">

<p>Previously, this value was used to identify clients across sessions. However, since this functionality is now handled using pre-shared keys in TLS 1.3, clients just generate a random session ID each time to avoid confusing intermediate clients which may only support TLS 1.2.</p>
<ul>
<li><code>20</code>: length of the session ID (between 0 and 32)</li>
<li><code>cc ce 0a ... 73 d1 b2</code>: session ID</li>
</ul>
</div>
<div class="segment" data-hex="0076130213031301c02fc02bc030c02c009ec0270067c028006b00a3009fcca9cca8ccaac0afc0adc0a3c09fc05dc061c057c05300a2c0aec0acc0a2c09ec05cc060c056c052c024006ac0230040c00ac01400390038c009c01300330032009dc0a1c09dc051009cc0a0c09cc050003d003c0035002f00ff" data-name="Cipher Suites">

<p>In this section of the handshake, the client lists all the cipher suites which it supports. Each cipher is identified by a two-byte number assigned by <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">IANA</a>. The server uses this info to find a preferable cipher that both sides support.</p>
<ul>
<li><code>00 76</code>: length of cipher suite list (118 bytes)</li>
<li><code>13 02 13 ... 2f 00 ff</code>: list of ciphers in order of preference<ul>
<li><code>13 02</code>: TLS_AES_256_GCM_SHA384</li>
<li><code>13 03</code>: TLS_CHACHA20_POLY1305_SHA256</li>
<li><code>13 01</code>: TLS_AES_128_GCM_SHA256</li>
<li><code>c0 2f</code>: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li><code>c0 2b</code>: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</li>
<li><code>c0 30</code>: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li><code>c0 2c</code>: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</li>
<li><code>00 9e</code>: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li><code>c0 27</code>: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li>
<li><code>00 67</code>: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li>
<li><code>c0 28</code>: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</li>
<li><code>00 6b</code>: TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</li>
<li><code>00 a3</code>: TLS_DHE_DSS_WITH_AES_256_GCM_SHA384</li>
<li><code>00 9f</code>: TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li><code>cc a9</code>: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</li>
<li><code>cc a8</code>: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</li>
<li><code>cc aa</code>: TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</li>
<li><code>c0 af</code>: TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8</li>
<li><code>c0 ad</code>: TLS_ECDHE_ECDSA_WITH_AES_256_CCM</li>
<li><code>c0 a3</code>: TLS_DHE_RSA_WITH_AES_256_CCM_8</li>
<li><code>c0 9f</code>: TLS_DHE_RSA_WITH_AES_256_CCM</li>
<li><code>c0 5d</code>: TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384</li>
<li><code>c0 61</code>: TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384</li>
<li><code>c0 57</code>: TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384</li>
<li><code>c0 53</code>: TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384</li>
<li><code>00 a2</code>: TLS_DHE_DSS_WITH_AES_128_GCM_SHA256</li>
<li><code>c0 ae</code>: TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8</li>
<li><code>c0 ac</code>: TLS_ECDHE_ECDSA_WITH_AES_128_CCM</li>
<li><code>c0 a2</code>: TLS_DHE_RSA_WITH_AES_128_CCM_8</li>
<li><code>c0 9e</code>: TLS_DHE_RSA_WITH_AES_128_CCM</li>
<li><code>c0 5c</code>: TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256</li>
<li><code>c0 60</code>: TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256</li>
<li><code>c0 56</code>: TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256</li>
<li><code>c0 52</code>: TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256</li>
<li><code>c0 24</code>: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</li>
<li><code>00 6a</code>: TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</li>
<li><code>c0 23</code>: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li>
<li><code>00 40</code>: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</li>
<li><code>c0 0a</code>: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</li>
<li><code>c0 14</code>: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
<li><code>00 39</code>: TLS_DHE_RSA_WITH_AES_256_CBC_SHA</li>
<li><code>00 38</code>: TLS_DHE_DSS_WITH_AES_256_CBC_SHA</li>
<li><code>c0 09</code>: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li>
<li><code>c0 13</code>: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li>
<li><code>00 33</code>: TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li>
<li><code>00 32</code>: TLS_DHE_DSS_WITH_AES_128_CBC_SHA</li>
<li><code>00 9d</code>: TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li><code>c0 a1</code>: TLS_RSA_WITH_AES_256_CCM_8</li>
<li><code>c0 9d</code>: TLS_RSA_WITH_AES_256_CCM</li>
<li><code>c0 51</code>: TLS_RSA_WITH_ARIA_256_GCM_SHA384</li>
<li><code>00 9c</code>: TLS_RSA_WITH_AES_128_GCM_SHA256</li>
<li><code>c0 a0</code>: TLS_RSA_WITH_AES_128_CCM_8</li>
<li><code>c0 9c</code>: TLS_RSA_WITH_AES_128_CCM</li>
<li><code>c0 50</code>: TLS_RSA_WITH_ARIA_128_GCM_SHA256</li>
<li><code>00 3d</code>: TLS_RSA_WITH_AES_256_CBC_SHA256</li>
<li><code>00 3c</code>: TLS_RSA_WITH_AES_128_CBC_SHA256</li>
<li><code>00 35</code>: TLS_RSA_WITH_AES_256_CBC_SHA</li>
<li><code>00 2f</code>: TLS_RSA_WITH_AES_128_CBC_SHA</li>
<li><code>00 ff</code>: TLS_EMPTY_RENEGOTIATION_INFO_SCSV</li>
</ul>
</li>
</ul>
<p>TLS 1.3 only supports five cipher suites, of which three are listed: TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, and TLS_AES_128_GCM_SHA256. However, 56 other cipher suites were sent in this message. They are present for backwards compatibility (since the client does not know whether the server supports TLS 1.3 yet), but these are not available in TLS 1.3.</p>
</div>
<div class="segment" data-hex="0100" data-name="Legacy Compression Methods">

<p>Previously, compression methods were listed here. However, it was discovered that through carefully crafted messages, an attacker could infer properties about the encrypted data in a TLS connection by analyzing the size of the compressed data, an attack that has since been dubbed <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a>. In TLS 1.3, compression is no longer supported, so this field contains a single supported compression method (none).</p>
<ul>
<li><code>01</code>: length of compression methods list</li>
<li><code>00</code>: no compression</li>
</ul>
</div>
<div class="segment" data-hex="0095" data-name="Extensions">

<p>The extensions section contains records providing more information about the client. A full list of extensions and their respective RFCs can be found <a href="https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml">here</a>.</p>
<ul>
<li><code>00 95</code>: length of extensions (149 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="000b000403000102" data-name="Extension: ec_point_formats">

<p>This extension lists the <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">elliptic curve</a> encodings that the client can parse, in order of preference.</p>
<ul>
<li><code>00 0b</code>: extension type (11 for ec_point_formats)</li>
<li><code>00 04</code>: extension data length (4 bytes)<ul>
<li><code>03</code>: length of format list (3 bytes)<ul>
<li><code>00</code>: uncompressed points are supported</li>
<li><code>01 02</code>: deprecated formats (<a href="https://standards.globalspec.com/std/1955141/ANSI%20X9.62">X.962</a>) which clients must still declare support for, as specified in <a href="https://www.rfc-editor.org/rfc/rfc8422.html#section-5.1.2">RFC 8422</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="000a00160014001d0017001e0019001801000101010201030104" data-name="Extension: supported_groups">

<p>This extension lists the elliptic curves which the client supports, in order of preference. </p>
<ul>
<li><code>00 0a</code>: extension type (10 for supported_groups)</li>
<li><code>00 16</code>: extension data length (22 bytes)<ul>
<li><code>00 14</code>: length of curve list (20 bytes)<ul>
<li><code>00 1d</code>: x25519</li>
<li><code>00 17</code>: secp256r1</li>
<li><code>00 1e</code>: x448</li>
<li><code>00 19</code>: secp512r1</li>
<li><code>00 18</code>: secp384r1</li>
<li><code>01 00</code>: ffdhe2048</li>
<li><code>01 01</code>: ffdhe3072</li>
<li><code>01 02</code>: ffdhe4096</li>
<li><code>01 03</code>: ffdhe6144</li>
<li><code>01 04</code>: ffdhe8192</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="00230000" data-name="Extension: session_ticket">

<p>This extension identifies the client for <a href="https://www.rfc-editor.org/rfc/rfc5077.html">TLS session resumption</a>. In this case, the client doesn&#39;t have a session ticket yet, so it requests one by sending a ticket of length zero.</p>
<ul>
<li><code>00 23</code>: extension type (35 for session_ticket)</li>
<li><code>00 00</code>: data length (none)</li>
</ul>
</div>
<div class="segment" data-hex="00160000" data-name="Extension: encrypt_then_mac">

<p>This extension is a relic of TLS 1.2, where the default MAC-then-encrypt behavior resulted in security vulnerabilities. It is not relevant to TLS 1.3.</p>
<ul>
<li><code>00 16</code>: extension type (22 for encrypt_then_mac)</li>
<li><code>00 00</code>: data length (none)</li>
</ul>
</div>
<div class="segment" data-hex="00170000" data-name="Extension: extended_master_secret">

<p>Similar to the encrypt-then-MAC extension, extended master secrets are another TLS 1.2 hardening meausre which is unnecessary in TLS 1.3.</p>
<ul>
<li><code>00 17</code>: extension type (23 for extended_master_secret)</li>
<li><code>00 00</code>: data length (none)</li>
</ul>
</div>
<div class="segment" data-hex="000d002a0028040305030603080708080809080a080b080408050806040105010601030303010302040205020602" data-name="Extension: signature_algorithms">

<p>This extension allows clients to declare which digital signature algorithms they support. Since clients rely on these algorithms to verify the server&#39;s identity, the server may take these values into account later in the handshake process.</p>
<ul>
<li><code>00 0d</code>: extension type (13 for signature_algorithms)</li>
<li><code>00 2a</code>: data length (42 bytes)<ul>
<li><code>00 28</code>: length of signature algorithms list (40 bytes)<ul>
<li><code>04 03</code>: ecdsa_secp256r1_sha256</li>
<li><code>05 03</code>: ecdsa_secp384r1_sha384</li>
<li><code>06 03</code>: ecdsa_secp521r1_sha512</li>
<li><code>08 07</code>: ed25519</li>
<li><code>08 08</code>: ed448</li>
<li><code>08 09</code>: rsa_pss_pss_sha256</li>
<li><code>08 0a</code>: rsa_pss_pss_sha384</li>
<li><code>08 0b</code>: rsa_pss_pss_sha512</li>
<li><code>08 04</code>: rsa_pss_rsae_sha256</li>
<li><code>08 05</code>: rsa_pss_rsae_sha384</li>
<li><code>08 06</code>: rsa_pss_rsae_sha512</li>
<li><code>04 01</code>: rsa_pkcs1_sha256</li>
<li><code>05 01</code>: rsa_pkcs1_sha384</li>
<li><code>06 01</code>: rsa_pkcs1_sha512</li>
<li><code>03 03</code>: SHA224 ECDSA</li>
<li><code>03 01</code>: SHA224 RSA</li>
<li><code>03 02</code>: SHA224 DSA</li>
<li><code>04 02</code>: SHA256 DSA</li>
<li><code>05 02</code>: SHA384 DSA</li>
<li><code>06 02</code>: SHA512 DSA</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="002b00050403040303" data-name="Extension: supported_versions">

<p>This extension lists the TLS versions which the client supports. This is how the server detects that the client is trying to initiate a TLS 1.3 session.</p>
<ul>
<li><code>00 2b</code>: extension type (43 for supported_versions)</li>
<li><code>00 05</code>: data length (5 bytes)<ul>
<li><code>04</code>: length of version list (4 bytes)<ul>
<li><code>03 04</code>: TLS 1.3</li>
<li><code>03 03</code>: TLS 1.2</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="002d00020101" data-name="Extension: psk_key_exchange_modes">

<p>This extension lists the supported key exchange modes for pre-shared keys. We aren&#39;t using pre-shared keys, so this extension won&#39;t be relevant.</p>
<ul>
<li><code>00 2d</code>: extension type (45 for psk_key_exchange_modes)</li>
<li><code>00 02</code>: data length (2 bytes)<ul>
<li><code>01 01</code>: PSK with (EC)DHE key establishment</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="003300260024001d00204b65e1788c1999350d0a44f50646a75c392584735d96d6d0b35b61c2f9375931" data-name="Extension: key_share">

<p>The client sends its public keys to the server using this extension. If the server doesn&#39;t support any of the key share algorithms, it may ask the client to resend the ClientHello message via a <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.4">Hello Retry Request</a>. This way, an unnecessary round trip can be avoided in most handshakes.</p>
<ul>
<li><code>00 33</code>: extension type (51 for key_share)</li>
<li><code>00 26</code>: data length (38 bytes)<ul>
<li><code>00 24</code>: length of key share list<ul>
<li><code>00 1d</code>: key exchange curve (x25519) </li>
<li><code>00 20</code>: key length (32 bytes)</li>
<li><code>4b 65 e1 ... 37 59 31</code>: public key, which was derived <a href="#client-handshake-key-generation">earlier</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<aside>

<p>If all the mismatching TLS versions scattered throughout the packet are confusing, don&#39;t worry. There&#39;s a whole section in the TLS 1.3 RFC documenting the various backwards compatibility measures taken to avoid confusing intermediate nodes, something they&#39;ve termed <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-D.4">middlebox compatibility mode</a>.</p>
</aside>

<h1 id="server-handshake-key-generation">Server Handshake Key Generation <a class="section-link" href="#server-handshake-key-generation">&sect;</a></h1><p>The server uses the same process as the client to generate its keypair. It starts by generating a private key:</p>
<pre><code class="hljs">d8b3916b7e1ed8d6fa07c7810eef53639b77e51e0fd8e044c1c9e1186fd63c49</code></pre><p>From this, the public key is derived.</p>
<pre><code class="hljs">011b5df090006e814ab8db60f6a2765cb90fe7fce73559e914796dafe6719c40</code></pre><h1 id="s--c-server-hello">S → C: Server Hello <a class="section-link" href="#s--c-server-hello">&sect;</a></h1><p>The server responds to Client Hello with connection parameters such as the TLS version it has chosen to use, the session ID, and its own public key in response to the key_shares sent by the client.</p>
<div class="server packet">
<div class="segment" data-hex="160303007a" data-name="Record Header">

<p>Similar to the previous message, the server also claims that the message version is TLS 1.2 to avoid confusing intermediate clients. However, at this point both the client and server have decided on using TLS 1.3. Some of the fields here are very similar to those in the previous message, so various sections are condensed and some redundant descriptions are omitted.</p>
<ul>
<li><code>16</code>: record type (22 for handshake)</li>
<li><code>03 03</code>: protocol version (TLS 1.2 for backwards compatibility)</li>
<li><code>00 7a</code>: length of payload (122 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="02000076" data-name="Handshake Header">

<ul>
<li><code>02</code>: message type (2 for ServerHello)</li>
<li><code>00 00 76</code>: message length (118 bytes)</li>
<li><code>03 03</code>: version (this field must be set to TLS 1.2 as per the TLS 1.3 spec)</li>
</ul>
</div>
<div class="segment" data-hex="0303b21fc7065806a4d46abbc3efea46c59d664440debce77c19305ec080430ae7b8" data-name="Random">

<p>Like the client, the server also provides 32 bytes of randomness.</p>
</div>
<div class="segment" data-hex="20cce0a325341c9485b11e794e263fe3c3399204aaec8dc73eb996cd79f973d1b2" data-name="Legacy Session ID">

<p>The server resends the session ID found in the Client Hello message, because this field is not used in TLS 1.3.</p>
</div>
<div class="segment" data-hex="1302" data-name="Cipher Suite">

<p>This field indicates that the server has chosen to use TLS_AES_256_GCM_SHA384 as the cipher suite for this session. This means that messages will be encrypted using <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES-256</a>, and all operations involving cryptographic hashes will use <a href="https://en.wikipedia.org/wiki/SHA-2">SHA-384</a>.</p>
</div>
<div class="segment" data-hex="00" data-name="Legacy Compression Methods">

<p>The only compression method which TLS 1.3 clients are allowed to offer is <code>00</code> (no compression), so the server selects that method.</p>
</div>
<div class="segment" data-hex="002e" data-name="Extensions Length">

<ul>
<li><code>00 2e</code>: length of extensions (46 byte)</li>
</ul>
</div>
<div class="segment" data-hex="002b00020304" data-name="Extension: supported_versions">

<ul>
<li><code>00 2b</code>: extension type (43 for supported_versions)</li>
<li><code>00 02</code>: data length (2 bytes)</li>
<li><code>03 04</code>: selected TLS version (TLS 1.3)</li>
</ul>
</div>
<div class="segment" data-hex="00330024001d0020011b5df090006e814ab8db60f6a2765cb90fe7fce73559e914796dafe6719c40" data-name="Extension: key_share">

<p>The server acknowledges the public key shared in the ClientHello message by responding with a public key using the same cipher. </p>
<ul>
<li><code>00 33</code>: extension type (51 for key_share)</li>
<li><code>00 24</code>: data length (36 bytes)<ul>
<li><code>00 1d</code>: key exchange curve (x25519)</li>
<li><code>00 20</code>: key length (32 bytes)</li>
<li><code>01 1b 5d ... 71 9c 40</code>: public key, which was derived <a href="#server-handshake-key-generation">earlier</a></li>
</ul>
</li>
</ul>
</div>
</div>

<h1 id="handshake-key-exchange">Handshake Key Exchange <a class="section-link" href="#handshake-key-exchange">&sect;</a></h1><p>At this point, both the client and the server are ready to perform the key exchange calculations necessary to secure the rest of the handshake. First, each party generates a shared secret by multiplying their private key by the other party&#39;s public key. On the client&#39;s side:</p>
<pre><code class="hljs">client_privkey x server_pubkey = shared_secret
186b7a9daf3855fa090bf29a69391dc1ee788393f2dba58a23cab0f6b96d6355 x
011b5df090006e814ab8db60f6a2765cb90fe7fce73559e914796dafe6719c40 =
4c75e186e47a2627bb4501955a051d516653d9570f34c660e623d26e2175b956</code></pre><p>On the server&#39;s side:</p>
<pre><code class="hljs">server_privkey x client_pubkey = shared_secret
d8b3916b7e1ed8d6fa07c7810eef53639b77e51e0fd8e044c1c9e1186fd63c49 x
4b65e1788c1999350d0a44f50646a75c392584735d96d6d0b35b61c2f9375931 = 
4c75e186e47a2627bb4501955a051d516653d9570f34c660e623d26e2175b956</code></pre><p>From here, TLS uses a process known as the <a href="https://datatracker.ietf.org/doc/html/rfc8446#section-7.1">key schedule</a> to generate keys from the shared secret. There are two primary cryptographic operations involved. The first is <code>hkdfExtract</code>, which introduces a new &quot;source of entropy&quot; (e.g. the shared secret) into the current key schedule state, making all future derived keys depend on the correctness of this value. The second is <code>deriveSecret</code>, which uses the key schedule state to actually generate a random key of a specific length. This process is necessary because TLS generally needs to create several keys deterministically from a single shared secret, and getting it wrong can have serious security implications.</p>
<p>The key schedule begins with the calculation of an &quot;early secret&quot;. This is used to include the pre-shared key in the key schedule. Since we don&#39;t have a PSK, this part is mostly irrelevant. However, the spec says that we still have to do it, just with dummy values.</p>
<pre><code class="hljs">earlySecret = <span class="hljs-title function_">hkdfExtract</span>(
    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-variable constant_">HASHLEN</span>), <span class="hljs-comment">// initial salt is zero </span>
    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-variable constant_">HASHLEN</span>)  <span class="hljs-comment">// replace PSK with string of zeroes of the same length</span>
);</code></pre><p>Next, calculate a derived secret from the early secret.</p>
<pre><code class="hljs">derivedSecret = <span class="hljs-title function_">deriveSecret</span>(earlySecret, <span class="hljs-string">&quot;derived&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>));</code></pre><p>Create the handshake secret using the shared value from key exchange and the derived secret from the previous step.</p>
<pre><code class="hljs"><span class="hljs-comment">// sharedSecret = 4c 75 e1 ...</span>
handshakeSecret = <span class="hljs-title function_">hkdfExtract</span>(derivedSecret, sharedSecret);</code></pre><p>For the next part, we need to pass the hash of the previously exchanged ClientHello and ServerHello messages to <code>deriveSecret</code> in a parameter called the <em>context</em>. This is why the Random field is included in the Hello messages: to prevent replay attacks. The Random fields change between handshakes, and thus, so does the context. Without this protection, an attacker could simply record a client connecting to the server and replay the handshake in an attempt to extract the key; however, since the Random field sent by the server in the attacker&#39;s session would be different from the value sent in the previous session, the handshake context changes, and different keys are derived.</p>
<p><code>handshakeContext</code> is created by applying a cryptographic hash function to the raw data of the ClientHello and Server Hello messages, excluding the record header.</p>
<pre><code class="hljs"><span class="hljs-comment">// client side</span>
clientHandshakeTrafficSecret = <span class="hljs-title function_">deriveSecret</span>(handshakeSecret, <span class="hljs-string">&quot;c hs traffic&quot;</span>, handshakeContext);

<span class="hljs-comment">// server side</span>
serverHandshakeTrafficSecret = <span class="hljs-title function_">deriveSecret</span>(handshakeSecret, <span class="hljs-string">&quot;s hs traffic&quot;</span>, handshakeContext);</code></pre><p>From here, we just need to calculate two additional values that we can feed to our actual cipher. In this case, our client and server settled on AES-256, so we&#39;ll need a <strong>key</strong> and an unpredictable <strong>initialization vector</strong>.</p>
<pre><code class="hljs"><span class="hljs-comment">// client credentials</span>
clientHandshakeKey = <span class="hljs-title function_">hkdfExpandLabel</span>(clientHandshakeTrafficSecret, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">32</span>);
clientHandshakeIV = <span class="hljs-title function_">hkdfExpandLabel</span>(clientHandshakeTrafficSecret, <span class="hljs-string">&quot;iv&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">12</span>);

<span class="hljs-comment">// server credentials</span>
serverHandshakeKey = <span class="hljs-title function_">hkdfExpandLabel</span>(serverHandshakeTrafficSecret, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">32</span>);
serverHandshakeIV = <span class="hljs-title function_">hkdfExpandLabel</span>(serverHandshakeTrafficSecret, <span class="hljs-string">&quot;iv&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">12</span>);</code></pre><p>The initialization vector (IV) ensures that every ciphertext is unique. Without a unique IV for each message, encrypting the same plaintext would produce the same ciphertext, which exposes a ton of information to attackers.</p>
<p>The code used to explain this section is available <a href="https://github.com/adrian154/blog/blob/main/generated-site/resources/tls/key-schedule.js">here</a>. </p>
<h2 id="perfect-forward-secrecy">Perfect Forward Secrecy <a class="section-link" href="#perfect-forward-secrecy">&sect;</a></h2><p>One important property offered by this complex key schedule is <a href="https://en.wikipedia.org/wiki/Forward_secrecy">perfect forward secrecy</a>: even if the server&#39;s certificate private key is eventually compromised, a client cannot decrypt recorded TLS traffic sent before the compromise. It&#39;s easy to see why this is the case: the public key the server sent in its key_share has nothing to do with the keypair in the server&#39;s certificate, so the keys used to calculate the shared secret are referred to as <em>ephemeral</em>. As long as these ephemeral keys aren&#39;t saved in a place where an attacker could obtain them eventually, the forward secrecy remains unbroken. Indeed, the TLS 1.3 RFC recommends immediately overwriting these values in  memory to reduce potential exposures.  </p>
<p>The only reason we&#39;re able to decrypt the capture is because I passed a flag to OpenSSL telling it to log some of the values used in key exchange (such as the handshake traffic secrets) to a text file that can be parsed by tools such as <a href="https://www.wireshark.org/">Wireshark</a>.</p>
<h1 id="s--c-change-cipher-spec">S → C: Change Cipher Spec <a class="section-link" href="#s--c-change-cipher-spec">&sect;</a></h1><p>Next, the server sends the Change Cipher Spec message. This isn&#39;t used in TLS 1.3, but to avoid confusing intermediate nodes, this message is still sent. From this point on, the rest of the handshake is encrypted.</p>
<div class="server packet">
<div class="segment" data-hex="140303000101" data-name="Record Header">

<ul>
<li><code>14</code>: record type (20 for Change Cipher Spec)</li>
<li><code>03 03</code>: protocol version (TLS 1.2 for backwards compatibility)</li>
<li><code>00 01</code>: length of payload (1 byte)</li>
<li><code>01</code>: unused</li>
</ul>
</div>
</div>

<h1 id="s--c-encrypted-extensions">S → C: Encrypted Extensions <a class="section-link" href="#s--c-encrypted-extensions">&sect;</a></h1><p>Our first encrypted message! Here, additional TLS extensions that aren&#39;t essential for key negotation are declared, so that minimal information about the session is leaked to eavesdroppers. There aren&#39;t any additional extensions in this session, so this message is empty.</p>
<p>All encrypted messages are contained within application data records, which provide the necessary info to receive and decrypt the data. For all messages after this one, we will simply be showing the decrypted payload. However, for the sake of completeness, this message will be shown in its entirety.</p>
<div class="server packet">
<div class="segment" data-hex="1703030017" data-name="Record Header">

<ul>
<li><code>17</code>: record type (23 for Application Data)</li>
<li><code>03 03</code>: protocol version (TLS 1.2 for backwards compatibility)</li>
<li><code>00 17</code>: length of payload (23 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="bf687d10e2f209" data-name="Encrypted Data">

<p>The TLS plaintext, encrypted using the server&#39;s key and the initialization vector derived in the key schedule (XOR&#39;d by the sequence number of the record&mdash;a counter starting from 0 that is increased every time a record is read&mdash;to create a unique IV for each record).</p>
</div>
<div class="segment" data-hex="661418d92aaf3626dfe5670f3127d6ed" data-name="Authentication Tag">

<p>The cipher outputs not only a ciphertext but also an authentication tag, which allows recipients to verify that the ciphertext was not modified while not revealing any information about the plaintext to attackers.</p>
</div>
</div>

<p>Here&#39;s the result that we get after decryption:</p>
<div class="server packet">
<div class="segment" data-hex="080000020000" data-name="Handshake Header">

<p>All extensions not necessary for performing key exchange must be sent here for maximum privacy.</p>
<ul>
<li><code>08</code>: message type (8 for EncryptedExtensions)</li>
<li><code>00 00 02</code>: message length (2 bytes)</li>
<li><code>00 00</code>: length of the extensions list (0 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="16" data-name="Data Type">

<p>The last byte denotes the actual record type (22 for handshake).</p>
</div>
</div>

<p>You can check out the code I used to decrypt the message <a href="https://github.com/adrian154/blog/blob/main/generated-site/resources/tls/decrypt.js">here</a>.</p>
<h1 id="s--c-certificate">S → C: Certificate <a class="section-link" href="#s--c-certificate">&sect;</a></h1><p>The server sends its certificate to the client. Here, the certificate message is abridged since most of it consists of the actual certificate itself, which is explained below.</p>
<p><em>Only the decrypted message is shown.</em></p>
<div class="server packet">
<div class="segment" data-hex="0b000fbb000fb700052a..000000051a..0000000564..000016" data-name="Handshake Header">

<ul>
<li><code>0b</code>: message type (11 for Certificate)</li>
<li><code>00 0f bb</code>: message length (4027 bytes)</li>
<li><code>00 0f b7</code>: certificate list length (4023 bytes)<ul>
<li>First certificate<ul>
<li><code>00 05 2a</code>: length (1322 bytes)</li>
<li><code>..</code>: certificate data</li>
<li><code>00 00</code>: extensions length (0 bytes)</li>
</ul>
</li>
<li>Second certificate<ul>
<li><code>00 05 1a</code>: length (1306 bytes)</li>
<li><code>..</code>: certificate data</li>
<li><code>00 00</code>: extensions length (0 bytes)</li>
</ul>
</li>
<li>Third certificate<ul>
<li><code>00 05 64</code>: length (1380 bytes)</li>
<li><code>..</code>: certificate data</li>
<li><code>00 00</code>: extensions length (0 bytes)</li>
</ul>
</li>
</ul>
</li>
<li><code>16</code>: actual record type (22 for handshake)</li>
</ul>
</div>
</div>

<p>The certificates themselves are serialized using a scheme called <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules</a>, or just DER.  DER is rather complicated, so this section doesn&#39;t aim to really explain its nuances; instead, it&#39;s meant to give you an idea of what&#39;s actually in a certificate and how it&#39;s stored. There&#39;s a lot of information in the certificate that isn&#39;t really necessary for understanding the TLS cryptosystem. Pay the most attention to the parts that associate the server&#39;s keypair with its identity (its domain name), as well as the parts proving the certificate&#39;s trustworthiness (the public key, and the fields identifying the signing certificate).</p>
<p>Here&#39;s the first certificate, dissected:</p>
<div class="server packet">
<div class="segment" data-hex="30820526" data-name="Certificate Header">

<p>A certificate actually has two components: the to-be-signed certificate, and the actual signature.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>82 05 26</code>: data length (1318 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="3082040e" data-name="To-Be-Signed Certificate Header">

<p>The to-be-signed certificate is where all the interesting information is stored, including the domain names which the certificate covers.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>82 04 0e</code>: data length (1038 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="a003020102" data-name="Version">

<p>This certificate uses <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> version 3.</p>
<ul>
<li><code>a0</code>: datatype (context-specific, &#39;version&#39;)</li>
<li><code>03</code>: data length (3 bytes)</li>
<li><code>02</code>: datatype (integer)</li>
<li><code>01</code>: data length (1 byte)</li>
<li><code>02</code>: version (2 for v3)</li>
</ul>
</div>
<div class="segment" data-hex="021204f99a1b9df5e7f17bb9f19166129e3ff810" data-name="Serial Number">

<p>Each certificate has a unique 20-byte serial number, which distinguishes it from other certificates issued by the same CA.</p>
<ul>
<li><code>02</code>: datatype (integer)</li>
<li><code>12</code>: data length (12 bytes)</li>
<li><code>04 f9 9a ... 3f f8 10</code>: serial number</li>
</ul>
</div>
<div class="segment" data-hex="300d06092a864886f70d01010b0500" data-name="Signature Algorithm">

<p>This section identifies the signature algorithm used by the issuer to sign the certificate. Signature algorithms are one of the many things in DER-land that are referenced through <a href="https://en.wikipedia.org/wiki/Object_identifier">object identifiers</a>, a hierarchical naming system created by the <a href="https://en.wikipedia.org/wiki/International_Telecommunication_Union">ITU</a> and the ISO/IEC. Object identifiers consist of a series of integers separated by periods.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>0d</code>: length</li>
<li><strong>Signature Algorithm</strong><ul>
<li><code>06</code>: datatype (object identifier)</li>
<li><code>09</code>: data length (9 bytes)</li>
<li><code>2a 86 48 ... 01 01 0b</code>: 1.2.840.113549.1.1.11, the object identifier for <code>sha256WithRSAEncryption</code></li>
</ul>
</li>
<li><strong>Parameters</strong><ul>
<li><code>05</code>: datatype (NULL)</li>
<li><code>00</code>: data length (0)</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="3032" data-name="Issuer Header">

<p>The following sections provides information about the issuer of the certificate through a pair of key-value attributes.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>32</code>: data length (50 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="310b3009060355040613025553" data-name="Issuer Country">

<p>This field identifies the country code of the issuer.</p>
<ul>
<li><code>31</code>: datatype (set)</li>
<li><code>0b</code>: data length (11 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>09</code>: data length (9 bytes)</li>
<li><code>06 03 55 04 06</code>: 2.5.4.6, the object identifier for the <code>id-at-countryname</code> property</li>
<li><code>13 02 55 53</code>: string (&quot;US&quot;)</li>
</ul>
</div>
<div class="segment" data-hex="31163014060355040a130d4c6574277320456e6372797074" data-name="Issuer Organization Name">

<p>This field identifies the name of the issuer&#39;s organization</p>
<ul>
<li><code>31</code>: datatype (set)</li>
<li><code>16</code>: data length (22 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>14</code>: data length (20 bytes)</li>
<li><code>06 03 55 04 0a</code>: 2.5.4.10, the object identifier for the <code>id-at-organizationName</code> property</li>
<li><code>13 0d 4c ... 79 70 74</code>: string (&quot;Let&#39;s Encrypt&quot;)</li>
</ul>
</div>
<div class="segment" data-hex="310b3009060355040313025233" data-name="Issuer Certificate Common Name">

<p>This field specifies the human-readable name of the signing certificate.</p>
<ul>
<li><code>31</code>: datatype (set)</li>
<li><code>0b</code>: data length (11 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>09</code>: data length (9 bytes)</li>
<li><code>06 03 55 04 03</code>: 2.5.4.3, the object identifier for the <code>id-at-commonName</code> property</li>
<li><code>13 02 52 33</code>: string (&quot;R3&quot;)</li>
</ul>
</div>
<div class="segment" data-hex="301e170d3232303231383036353132385a170d3232303531393036353132375a" data-name="Validity">

<p>This section provides the dates between which the certificate is valid. This is how certificate expiration works.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1e</code>: data length (30 bytes)</li>
<li><code>17 0d 32 ... 32 38 5a</code>: earliest valid time (Feb 18, 2022 6:51:28)</li>
<li><code>17 0d 32 ... 32 37 5a</code>: latest valid time (May 19, 2022 6:51:27)</li>
</ul>
<p>This is the last of the issuer properties included in this certificate.</p>
</div>
<div class="segment" data-hex="301b3119301706035504031310746573742e626974686f6c652e646576" data-name="Common Name">

<p>This field specifies the human-readable name for our certificate.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1b</code>: data length (27 bytes)</li>
<li><code>31</code>: datatype (set)</li>
<li><code>19</code>: data length (25 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>17</code>: data length (23 bytes)</li>
<li><code>06 03 55 04 03</code>: 2.5.4.3, the object identifier for <code>id-at-commonName</code></li>
<li><code>13 10 74 ... 64 65 76</code>: string (&quot;test.bithole.dev&quot;)</li>
</ul>
</div>
<div class="segment" data-hex="30820122300d06092a864886f70d0101010500" data-name="Subject Public Key Info">

<p>This part provides information about our public key. (Recall that the point of a certificate is to establish a connection between our identity and our public key.)</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>82 01 22</code>: data length (290 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>0d</code>: data length (13 bytes)</li>
<li><code>06 09 2a ... 01 01 01</code>: 1.2.840.113549.1.1.1, the object identifier for <code>rsaEncryption</code></li>
<li><code>05 00</code>: paramters (NULL)</li>
</ul>
</div>
<div class="segment" data-hex="0382010f003082010a0282010100b587501904bd9198c9c9eab873d4a249dcc37632e5ed3d22bcbab4126b5727fbfedc8975d073cd2e9f9faef3243c145a6458531b831515778bf76125c07a4148fe39b6eaddd38539d5f7bdf1dbc3a9bc014cb4fbce004879f4cdf84164bcd8d6f1f95ce730f4cfe91908cf2b15a4a60b26d2c4d31c4c850976d40d775f103bf33deb293bc8a6412865c596e0a07e8c38d72b8d4a981b518738cb6843ddc2574c2e279db10e4ce88d5fbe0502ca4ed97eee1f820894258d6a8deb78aa0f69b6ebddd5e991732cc19642bec153e6c874c3393a90dde0aae55b61417e96c0e695eb66fb9ddcbc2af5e6b8af4e61357ed1b0abe8a2efe9323c5fd14f6af30afa19b90203010001" data-preview-truncate="47" data-name="Subject Public Key">

<ul>
<li><code>03</code>: datatype (bitstring)</li>
<li><code>82010f</code>: data length (271 bytes)</li>
<li><code>00 30 82 ... 01 00 01</code>: our RSA public key</li>
</ul>
</div>
<div class="segment" data-hex="a382024b30820247" data-name="Extensions Header">

<p>The following sections contain X.509 <em>extensions</em>, which provide additional certificate info.</p>
<ul>
<li><code>a3</code>: datatype (context-specific, &#39;Extensions&#39;)</li>
<li><code>82 02 4b</code>: data length (587 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>82 02 47</code>: data length (583 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="300e0603551d0f0101ff0404030205a0" data-name="Extension: Key Usage">

<p>This extension lists the tasks which a key can be used for. For example, a CA may want to restrict the ability to sign certificates to only a handful of intermediate CAs. The Certificate Sign bit in this extension allows CAs to control the capabilities of each certificate they issue.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>0e</code>: data length (14 bytes)</li>
<li><code>06 03 55 1d 0f</code>: 2.5.29.15, the object identifier for <code>id-ce-keyUsage</code></li>
<li><code>01 01 ff</code>: the extension is critical; parsers cannot accept this certificate unless they are able to understand this extension</li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>04</code>: data length (4 bytes)</li>
<li><code>03</code>: datatype (bitstring)</li>
<li><code>02</code>: data length (2 bytes)</li>
<li><code>05</code>: padding bits (5)</li>
<li><code>a0</code>: bitfields describing the key usage</li>
</ul>
<p><code>0xa0</code> in binary is 10100000; the two set bits represent the Digital Signature and Key Encipherment usages.</p>
</div>
<div class="segment" data-hex="301d0603551d250416301406082b0601050507030106082b06010505070302" data-name="Extension: Extended Key Usage">

<p>This extension is included in end certificates. It further restricts them to <strong>only</strong> the purposes listed within this extension. In this case, this certificate is valid for server authentication and client authentication.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1d</code>: data length (29 bytes)</li>
<li><code>06 03 55 1d 25</code>: 2.5.92.37, the object identifier for <code>id-ce-extKeyUsage</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>16</code>: data length (22 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>14</code>: data length (20 bytes)</li>
<li><code>06 08 2b ... 07 03 01</code>: 1.3.6.1.5.5.7.3.1, the object identifier for <code>id-kp-serverAuth</code> </li>
<li><code>06 08 2b ... 07 03 02</code>: 1.3.6.1.5.5.7.3.2, the object identifier for <code>id-kp-clientAuth</code></li>
</ul>
</div>
<div class="segment" data-hex="300c0603551d130101ff04023000" data-name="Extension: Basic Constraints">

<p>This extension offers more fine-grained controls over what certificates can be issued using this certificate. Since we aren&#39;t a CA and can&#39;t issue <em>any</em> certificates, no constraints are listed here.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>0c</code>: data length (12 bytes)</li>
<li><code>06 03 55 1d 13</code>: 2.5.29.19, the object identifier for <code>id-ce-basicConstraints</code></li>
<li><code>01 01 ff</code>: the extension is critical; parsers cannot accept this certificate unless they are able to understand this extension</li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>02</code>: data length (2 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>00</code>: data length (0)</li>
</ul>
</div>
<div class="segment" data-hex="301d0603551d0e04160414e7a1622dade131944f1341c83a37a5b96336263e" data-name="Extension: Subject Key Identifier">

<p>This extension uniquely identifies the certificate based on its public key. This value can be referenced in any certificates issued using this certificate.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1d</code>: data length (29 bytes)</li>
<li><code>06 03 55 1d 0e</code>: 2.5.29.14, the object identifier for <code>id-ce-subjectKeyIdentifier</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>16</code>: data length (22 bytes)</li>
<li><code>04 14 e7 ... 36 26 3e</code>: the subject key identifier</li>
</ul>
</div>
<div class="segment" data-hex="301f0603551d23041830168014142eb317b75856cbae500940e61faf9d8b14c2c6" data-name="Extension: Authority Key Identifier">

<p>This extension contains the subject key identifier of the signing certificate(s), i.e. the authorities. The purpose of this extension is to assist in establishing a chain of trust.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1f</code>: data length (31 bytes)</li>
<li><code>06 03 55 1d 23</code>: 2.5.29.35, the object identifier for <code>id-ce-authorityKeyIdentifier</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>18</code>: data length (24 bytes)</li>
<li><code>80 14 14 ... 14 2c c6</code>: the subject key identifier</li>
</ul>
</div>
<div class="segment" data-hex="305506082b0601050507010104493047302106082b060105050730018615687474703a2f2f72332e6f2e6c656e63722e6f7267302206082b060105050730028616687474703a2f2f72332e692e6c656e63722e6f72672f" data-name="Extension: Authority Information Access">

<p>This extension provides information about where to access various services offered by the certificate issuer, such as <a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OCSP</a> (which allows clients to query the issuer regarding the validity of a certificate online).</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>55</code>: data length (85 bytes)</li>
<li><code>06 08 2b 06 01 05 05 07 01 01</code>: 1.3.6.1.5.5.7.1.1, the object identifier for <code>id-pe-authorityInfoAccess</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>49</code>: data length (73 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>47</code>: data length (71 bytes)</li>
<li><strong>OCSP</strong><ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>21</code>: data length (33 bytes)</li>
<li><code>06 08 2b 06 01 05 05 07 30 01</code>: 1.3.6.1.5.5.7.48.1, the object identifier for <code>id-ad-ocsp</code></li>
<li><code>86 15 68 ... 6f 72 67</code>: URL (<a href="http://r3.o.lencr.org">http://r3.o.lencr.org</a>)</li>
</ul>
</li>
<li><strong>CA Issuer</strong><ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>22</code>: data length (34 bytes)</li>
<li><code>06 08 2b 06 01 05 05 07 30 02</code>: 1.3.6.1.5.5.7.48.2, the object identifier for <code>id-ad-caIssuers</code></li>
<li><code>86 16 68 ... 72 67 2f</code>: URL (<a href="http://r3.i.lencr.org/">http://r3.i.lencr.org/</a>)</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="301b0603551d11041430128210746573742e626974686f6c652e646576" data-name="Extension: Subject Alternative Names">

<p>This extension allows the certificate to identify other hostnames in addition to the subject name field which the subject may authenticate as. This certificate just serves one domain, <code>test.bithole.dev</code>, so this extension isn&#39;t very interesting.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>1b</code>: data length (27 bytes)</li>
<li><code>06 03 55 1d 11</code>: 2.5.29.17, the object identifier for <code>id-ce-subjectAltName</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>14</code>: data length (20 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>12</code>: data length (18 bytes)</li>
<li><code>82 10 74 ... 64 65 76</code>: string (&quot;test.bithole.dev&quot;)</li>
</ul>
</div>
<div class="segment" data-hex="304c0603551d20044530433008060667810c0102013037060b2b0601040182df130101013028302606082b06010505070201161a687474703a2f2f6370732e6c657473656e63727970742e6f7267" data-name="Extension: Policy Information">

<p>This extension describes where to access the issuer&#39;s Certificate Practice Statement, which describes the CA&#39;s policy for issuing certificates.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>4c</code>: data length (76 bytes)</li>
<li><code>06 03 55 1d 20</code>: 2.5.29.32, the object identifier for <code>id-ce-certificatePolicies</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>45</code>: data length (69 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>43</code>: data length (67 bytes)</li>
<li><strong>Policy 1</strong><ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>08</code>: data length (8 bytes)</li>
<li><code>06 06 67 81 0c 01 02 01</code>: 2.23.140.1.2.1, the object identifier for <a href="https://cabforum.org/object-registry/">baseline requirements</a></li>
</ul>
</li>
<li><strong>Policy 2</strong><ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>37</code>: data length (55 bytes)</li>
<li><code>06 0b 2b ... 01 01 01</code>: 1.3.6.1.4.1.44947.1.1.1, the object identifier for Let&#39;s Encrypt&#39;s CPS</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>28</code>: data length (40 bytes)</li>
<li><code>30</code>: datatype (sequence)</li>
<li><code>26</code>: data length (38 bytes)</li>
<li><code>06 08 2b ... 07 02 01</code>: 1.3.6.1.5.5.7.2.1, the object identifier for <code>id-qt-cps</code></li>
<li><code>16 1a 68 ... 6f 72 67</code>: URL (<a href="https://cps.letsencrypt.org">https://cps.letsencrypt.org</a>)</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="30820104060a2b06010401d6790204020481f50481f200f00076006f5376ac31f03119d89900a45115ff77151c11d902c10029068db2089a37d9130000017f0bd084e50000040300473045022100eee2822add6ff5c9cc507f0a8a5f174551205becfbf0031e962d8f4ce916090b022049cf3e53e653385c0745902e8c7901e4971b25b436eafb22f2b83c222747b3c500760046a555eb75fa912030b5a28969f4f37d112c4174befd49b885abf2fc70fe6d470000017f0bd084e10000040300473045022018c8aee5cff4fdc7b19232bc8533de5890f75820f85ac40d11c5696e9ab9912e022100a1dddb603ec9b815f067ac0ac6a5229146fdcf932b5ad4ff28ae892aee813caa" data-name="Extension: Certificate Transparency" data-x="1">

<p><a href="https://certificate.transparency.dev/">Certificate Transparency</a> is a standard for... well... certificate transparency! The idea is for CAs to permanently log every certificate they issue, making it easier to track down malicious or mistakenly issued certificates. There are three types of groups involved in CT:</p>
<ul>
<li>CAs, who submit certificates to logs</li>
<li>Logs, which validate certificates and log them, returning a Signed Certificate Timestamp (a promise that the certificate will be added to the log). The data structure which logs store issuances in (a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a>) is constructed using cryptographic primitives such that it is impossible to remove an entry without consumers of the log noticing.</li>
<li>Monitors, which receive updates from logs and ensure that the logs are not misbehaving. Monitors may also offer services that contact you when a new certificate is issued for one of your domains.</li>
</ul>
<p>Certificate Transparency is further strengthened by the fact that some browsers (such as <a href="https://chromium.googlesource.com/chromium/src/+/master/net/docs/certificate-transparency.md">Chrome</a>) now display an SSL error if a certificate lacks Certificate Transparency information, preventing CAs from issuing certificates off the record.</p>
<p>This is all a very surface-level description of the Certificate Transparency ecosystem. For more information, you should check out the <a href="https://certificate.transparency.dev/howctworks/">official website</a>.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>820104</code>: data length (260 bytes)</li>
<li><code>06 0a 2b ... 02 04 02</code>: 1.3.6.1.4.1.11129.2.4.2, the object identifier for <code>SignedCertificateTimestampList</code></li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>81 f5</code>: data length (245 bytes)</li>
<li><code>04</code>: datatype (octet string)</li>
<li><code>81 f2</code>: data length (242 bytes)</li>
<li><code>00 f0</code>: list length (240 bytes)</li>
<li><strong>SCT #1 (Sectigo)</strong> <ul>
<li><code>00 76</code>: length</li>
<li><code>00</code>: version </li>
<li><code>6f 53 76 ... 37 d9 13</code>: log ID (Sectigo &quot;Mammoth&quot;)</li>
<li><code>00 00 01 7f 0b d0 84 e5</code>: timestamp (Feb 17, 2022)</li>
<li><code>00 00</code>: extensions length (0 bytes)</li>
<li><code>04 03</code>: signature algorithm (0x0403 for ecdsa_secp256r1_sha256)</li>
<li><code>00 47</code>: signature length (71 bytes)</li>
<li><code>30 45 02 ... 47 b3 c5</code>: signature</li>
</ul>
</li>
<li><strong>SCT #2 (Google)</strong><ul>
<li><code>00 76</code>: length</li>
<li><code>00</code>: version </li>
<li><code>46 a5 55 ... fe 6d 47</code>: log ID (Google &quot;Xenon2022&quot;)</li>
<li><code>00 00 01 7f 0b d0 84 e1</code>: timestamp (Feb 17, 2022)</li>
<li><code>00 00</code>: extensions length (0 bytes)</li>
<li><code>04 03</code>: signature algorithm (0x0403 for ecdsa_secp256r1_sha256)</li>
<li><code>00 47</code>: signature length (71 bytes)</li>
<li><code>30 45 02 ... 81 3c aa</code>: signature</li>
</ul>
</li>
</ul>
</div>
<div class="segment" data-hex="300d06092a864886f70d01010b0500" data-name="Signature Algorithm Identifier">

<p>This field identifies the signature algorithm the issuer used to sign the certificate.</p>
<ul>
<li><code>30</code>: datatype (sequence)</li>
<li><code>0d</code>: data length (13 bytes)</li>
<li><code>06 09 2a ... 01 01 0b</code>: 1.2.840.113549.1.1.11, the object identifier for sha256WithRSAEncryption</li>
<li><code>05 00</code>: parameters (NULL)</li>
</ul>
</div>
<div class="segment" data-hex="03820101007c8acf6d06a816072795343919d9bb769fca5fe24838129408127831eec82333ed91463dbb46fcbdb4640a156969f87dd65a724f10b36628dc109ac26f763e04210d9a44296c6a7952ff4cb3a5d885e9069feea17ef2ab8b858b293cc3217d7cc1b3316db027cd78a5ef546c76352d4016815674e4e093847d691fab2fe8d8ece833355c3e15e96586d12729bd97117b64437c69050488b2b09d8cf690345ce80507c58e5ecffd3ed8e242d12d6e2677a40c0c608d055cfd370dc6b00da27f1df0003b7b427b8f6c8049deba5d040beba054b1dafa6881669a41ff9d815f31bfa52175ddd0b41be5e72b82ea51f9a10d62e6b617d9ad63bedaf7cadb1cefbcd5" data-name="Signature">

<p>The actual signature of the certificate.</p>
<ul>
<li><code>03</code>: datatype (bitstring)</li>
<li><code>82 01 01</code>: data length (257 bytes)</li>
<li><code>00 7c 8a ... ef bc d5</code>: the signature</li>
</ul>
</div>
</div>

<p>This certificate contains some information about where to proceed next in the chain of trust. The easiest way is to probably look for the certificate whose subject key identifier matches the authority key identifier listed here, which is <code>142eb31...14c2c6</code>. If we look at R3, we&#39;ll see that its subject key identifier has that value; we can then validate the signature included in <code>test.bithole.dev</code> using R3&#39;s public key. Repeat the process, and we reach ISRG Root X1, which is signed by itself since it&#39;s a root certificate.</p>
<p>The three certificates are available for download: <a href="resources/tls/cert1.crt">test.bithole.dev</a>, <a href="resources/tls/cert2.crt">R3</a>, and <a href="resources/tls/cert3.crt">ISRG Root X1</a>. You can dump information about these certificates using OpenSSL from the terminal:</p>
<div class="limited-height-code">

<pre><code class="hljs">$ openssl x509 -in cert2.crt -inform der -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            91:2b:08:4a:cf:0c:18:a7:53:f6:d6:2e:25:a7:5f:5a
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = US, O = Internet Security Research Group, CN = ISRG Root X1
        Validity
            Not Before: Sep  4 00:00:00 2020 GMT
            Not After : Sep 15 16:00:00 2025 GMT
        Subject: C = US, O = Let&#x27;s Encrypt, CN = R3
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:bb:02:15:28:cc:f6:a0:94:d3:0f:12:ec:8d:55:
                    92:c3:f8:82:f1:99:a6:7a:42:88:a7:5d:26:aa:b5:
                    2b:b9:c5:4c:b1:af:8e:6b:f9:75:c8:a3:d7:0f:47:
                    94:14:55:35:57:8c:9e:a8:a2:39:19:f5:82:3c:42:
                    a9:4e:6e:f5:3b:c3:2e:db:8d:c0:b0:5c:f3:59:38:
                    e7:ed:cf:69:f0:5a:0b:1b:be:c0:94:24:25:87:fa:
                    37:71:b3:13:e7:1c:ac:e1:9b:ef:db:e4:3b:45:52:
                    45:96:a9:c1:53:ce:34:c8:52:ee:b5:ae:ed:8f:de:
                    60:70:e2:a5:54:ab:b6:6d:0e:97:a5:40:34:6b:2b:
                    d3:bc:66:eb:66:34:7c:fa:6b:8b:8f:57:29:99:f8:
                    30:17:5d:ba:72:6f:fb:81:c5:ad:d2:86:58:3d:17:
                    c7:e7:09:bb:f1:2b:f7:86:dc:c1:da:71:5d:d4:46:
                    e3:cc:ad:25:c1:88:bc:60:67:75:66:b3:f1:18:f7:
                    a2:5c:e6:53:ff:3a:88:b6:47:a5:ff:13:18:ea:98:
                    09:77:3f:9d:53:f9:cf:01:e5:f5:a6:70:17:14:af:
                    63:a4:ff:99:b3:93:9d:dc:53:a7:06:fe:48:85:1d:
                    a1:69:ae:25:75:bb:13:cc:52:03:f5:ed:51:a1:8b:
                    db:15
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Certificate Sign, CRL Sign
            X509v3 Extended Key Usage:
                TLS Web Client Authentication, TLS Web Server Authentication
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Subject Key Identifier:
                14:2E:B3:17:B7:58:56:CB:AE:50:09:40:E6:1F:AF:9D:8B:14:C2:C6
            X509v3 Authority Key Identifier:
                keyid:79:B4:59:E6:7B:B6:E5:E4:01:73:80:08:88:C8:1A:58:F6:E9:9B:6E

            Authority Information Access:
                CA Issuers - URI:http://x1.i.lencr.org/

            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://x1.c.lencr.org/

            X509v3 Certificate Policies:
                Policy: 2.23.140.1.2.1
                Policy: 1.3.6.1.4.1.44947.1.1.1

    Signature Algorithm: sha256WithRSAEncryption
         85:ca:4e:47:3e:a3:f7:85:44:85:bc:d5:67:78:b2:98:63:ad:
         75:4d:1e:96:3d:33:65:72:54:2d:81:a0:ea:c3:ed:f8:20:bf:
         5f:cc:b7:70:00:b7:6e:3b:f6:5e:94:de:e4:20:9f:a6:ef:8b:
         b2:03:e7:a2:b5:16:3c:91:ce:b4:ed:39:02:e7:7c:25:8a:47:
         e6:65:6e:3f:46:f4:d9:f0:ce:94:2b:ee:54:ce:12:bc:8c:27:
         4b:b8:c1:98:2f:a2:af:cd:71:91:4a:08:b7:c8:b8:23:7b:04:
         2d:08:f9:08:57:3e:83:d9:04:33:0a:47:21:78:09:82:27:c3:
         2a:c8:9b:b9:ce:5c:f2:64:c8:c0:be:79:c0:4f:8e:6d:44:0c:
         5e:92:bb:2e:f7:8b:10:e1:e8:1d:44:29:db:59:20:ed:63:b9:
         21:f8:12:26:94:93:57:a0:1d:65:04:c1:0a:22:ae:10:0d:43:
         97:a1:18:1f:7e:e0:e0:86:37:b5:5a:b1:bd:30:bf:87:6e:2b:
         2a:ff:21:4e:1b:05:c3:f5:18:97:f0:5e:ac:c3:a5:b8:6a:f0:
         2e:bc:3b:33:b9:ee:4b:de:cc:fc:e4:af:84:0b:86:3f:c0:55:
         43:36:f6:68:e1:36:17:6a:8e:99:d1:ff:a5:40:a7:34:b7:c0:
         d0:63:39:35:39:75:6e:f2:ba:76:c8:93:02:e9:a9:4b:6c:17:
         ce:0c:02:d9:bd:81:fb:9f:b7:68:d4:06:65:b3:82:3d:77:53:
         f8:8e:79:03:ad:0a:31:07:75:2a:43:d8:55:97:72:c4:29:0e:
         f7:c4:5d:4e:c8:ae:46:84:30:d7:f2:85:5f:18:a1:79:bb:e7:
         5e:70:8b:07:e1:86:93:c3:b9:8f:dc:61:71:25:2a:af:df:ed:
         25:50:52:68:8b:92:dc:e5:d6:b5:e3:da:7d:d0:87:6c:84:21:
         31:ae:82:f5:fb:b9:ab:c8:89:17:3d:e1:4c:e5:38:0e:f6:bd:
         2b:bd:96:81:14:eb:d5:db:3d:20:a7:7e:59:d3:e2:f8:58:f9:
         5b:b8:48:cd:fe:5c:4f:16:29:fe:1e:55:23:af:c8:11:b0:8d:
         ea:7c:93:90:17:2f:fd:ac:a2:09:47:46:3f:f0:e9:b0:b7:ff:
         28:4d:68:32:d6:67:5e:1e:69:a3:93:b8:f5:9d:8b:2f:0b:d2:
         52:43:a6:6f:32:57:65:4d:32:81:df:38:53:85:5d:7e:5d:66:
         29:ea:b8:dd:e4:95:b5:cd:b5:56:12:42:cd:c4:4e:c6:25:38:
         44:50:6d:ec:ce:00:55:18:fe:e9:49:64:d4:4e:ca:97:9c:b4:
         5b:c0:73:a8:ab:b8:47:c2</code></pre></div>

<p>This yields pretty much the same information as what was listed in the manual breakdown, sans all the byte-level details.</p>
<h1 id="s--c-certificate-verify">S → C: Certificate Verify <a class="section-link" href="#s--c-certificate-verify">&sect;</a></h1><p>This message allows the server to prove that it controls the private keys behind the certificate by signing a hash of all the messages sent up until now. This also ensures that none of those messages were tampered with.</p>
<p><em>Only the decrypted message is shown.</em></p>
<div class="server packet">
<div class="segment" data-hex="0f000104" data-name="Handshake Header">

<ul>
<li><code>0f</code>: message type (15 for CertificateVerify)</li>
<li><code>00 01 04</code>: message length (260 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="0804" data-name="Signature Algorithm">

<p>The algorithm used to sign the context hash (0x0804 for <code>rsa_pss_rsae_sha256</code>).</p>
</div>
<div  class="segment" data-hex="0100394fbf6cbd019e90b4a97a405d3f16ee5510dc3b34b5e1e844c75974be587137e7e25482a10decc7ba97219e880715c766e78d0fafad963cb95996a111fe798bc47060f2eb45b398b50a2e616c5566720865b7572d5ada5a5ea9168311c5ed3e1b49b03b04c463fca9ba1c7621b940731db06f4cda19c78933f1be5a40d4fda7848bd5c67cfe2d7c85dadd9d52a1d9db6b853ac877926ed5ea72cb35f852c664e98c2ac377cd8b3217d059356df20c3e86b6042ad88a39b676f2a338fb4909710b1c208336415959891f5e522ea6e7468f128adc391b643749ed56cda3280d59ef92ce26f66bb0b89f5c9ccfdf8fab7da7b5882bca27cc496ea0767f9ca44e9e" data-name="Signature" data-preview-truncate="47">

<p>This is the actual signature. We can verify this with a little code.</p>
<p>First, we construct the context hash, similar to what we did earlier to derive the handshake keys.</p>
<pre><code class="hljs">contextHash = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&quot;sha384&quot;</span>).<span class="hljs-title function_">update</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([
    <span class="hljs-title class_">ClientHello</span>,
    <span class="hljs-title class_">ServerHello</span>,
    <span class="hljs-title class_">EncryptedExtensions</span>,
    <span class="hljs-title class_">Certificate</span>
])).<span class="hljs-title function_">digest</span>();</code></pre><p>Next, we have to apply some padding to create the actual data which was signed.</p>
<pre><code class="hljs">data = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([
    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">64</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0x20</span>)), <span class="hljs-comment">// 64 spaces</span>
    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;TLS 1.3, server CertificateVerify&quot;</span>, <span class="hljs-string">&quot;ascii&quot;</span>), <span class="hljs-comment">// context string</span>
    <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1</span>), <span class="hljs-comment">// null byte</span>
    contextHash <span class="hljs-comment">// content to be signed</span>
]);</code></pre><p>Finally, we can verify the signature.</p>
<pre><code class="hljs"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(crypto.<span class="hljs-title function_">verify</span>(
    <span class="hljs-string">&quot;sha256&quot;</span>,
    data,
    {key, <span class="hljs-attr">padding</span>: crypto.<span class="hljs-property">constants</span>.<span class="hljs-property">RSA_PKCS1_PSS_PADDING</span>},
    signature
)); <span class="hljs-comment">// -&gt; &quot;true&quot;</span></code></pre><p>Even if a single bit of any of the inputs is modified, the signature will fail to verify. You can check out the full script <a href="https://github.com/adrian154/blog/blob/main/generated-site/resources/tls/certificate-verify.js">here</a>.</p>
</div>
<div class="segment" data-hex="16" data-name="Data Type">

<p>The last byte denotes the actual record type (22 for handshake).</p>
</div>
</div>

<h1 id="s--c-finished">S → C: Finished <a class="section-link" href="#s--c-finished">&sect;</a></h1><p>As the name implies, this is the last message sent by the server in the handshake. It contains the HMAC of all messages sent up to this point, created using a key derived from the server&#39;s handshake traffic secret, guaranteeing that none of the handshake has been interfered with.</p>
<p><em>Only the decrypted message is shown.</em></p>
<div class="server packet">
<div class="segment" data-hex="14000030" data-name="Handshake Header">

<ul>
<li><code>14</code>: message type (20 for Finished)</li>
<li><code>00 00 30</code>: message length (48 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="89625ec1d535045663cf6237a38b8d220dd00fe4ea50bfe2d51573680becf1c8bbae0421cb667bff10bc546c017aaef6" data-name="Verify Data">

<p>The first step towards generating the verification data is to derive a new key like so;</p>
<pre><code class="hljs">serverFinishedKey = <span class="hljs-title function_">hkdfExpandLabel</span>(serverHandshakeTrafficSecret, <span class="hljs-string">&quot;finished&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-variable constant_">HASHLEN</span>);</code></pre><p>Next, we compute yet another context hash, this time including the CertificateVerify message.</p>
<pre><code class="hljs">contextHash = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&quot;sha384&quot;</span>).<span class="hljs-title function_">update</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([
    <span class="hljs-title class_">ClientHello</span>,
    <span class="hljs-title class_">ServerHello</span>,
    <span class="hljs-title class_">EncryptedExtensions</span>,
    <span class="hljs-title class_">Certificate</span>,
    <span class="hljs-title class_">CertificateVerify</span>
])).<span class="hljs-title function_">digest</span>();</code></pre><p>Finally, we can compute the verification data.</p>
<pre><code class="hljs"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&quot;sha384&quot;</span>, finishedKey)
                  .<span class="hljs-title function_">update</span>(contextHash)
                  .<span class="hljs-title function_">digest</span>()
                  .<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;hex&quot;</span>));</code></pre><p>This yields:</p>
<pre><code class="hljs">89625ec1d535045663cf6237a38b8d220dd00fe4ea50bfe2d51573680becf1c8bbae0421cb667bff10bc546c017aaef6</code></pre><p>which matches the value sent by the server, helping the client confirm that the authentication portion of the handshake is legitimate, and the derived keys are correct.</p>
</div>
</div>

<aside>

<p>This part of the handshake relies on <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>, which you can think of as an extension of a regular cryptographic hash. An HMAC takes not one but two parameters: a secret key, and the data to be hashed. The other party can compare the resulting hash with the expected value, and check whether the data matches up. The key is necessary because anyone can create a regular hash, which provides no guarantee of authenticity.</p>
<p><em>Couldn&#39;t we accomplish the same thing by simply concatenating the key and the data, and then hashing?</em>, you may be asking. This is a very natural instinct, but it has a serious flaw: under certain circumstances, it may be possible to append data to the message while still producing a valid hash. This is known as a <a href="https://en.wikipedia.org/wiki/Length_extension_attack">length extension attack</a>. While there are ways to prevent this, those mitigations introduce their own vulnerabilities. Try to squash those, and you end up reinventing HMACs.</p>
</aside>

<h1 id="c--s-change-cipher-spec">C → S: Change Cipher Spec <a class="section-link" href="#c--s-change-cipher-spec">&sect;</a></h1><p>The client also sends a Change Cipher Spec message to the server, which is ignored in TLS 1.3. The byte-level analysis is omitted since it is identical to the one <a href="#s--c-change-cipher-spec">sent by the server</a> earlier in the handshake.</p>
<h1 id="c--s-finished">C → S: Finished <a class="section-link" href="#c--s-finished">&sect;</a></h1><p>Like the server, the client also sends a Finished message to complete the handshake. </p>
<p><em>Only the decrypted message is shown.</em></p>
<div class="client packet">
<div class="segment" data-hex="14000030" data-name="Handshake Header">

<ul>
<li><code>14</code>: message type (20 for Finished)</li>
<li><code>00 00 30</code>: message length (48 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="13e0061c0160d048c9ea16964b12d5340630c8e30f04c48b895f98f898113d31b2c9653af573952ad5ead6719b34fc17" data-name="Verify Data">

<p>The value of this field is derived in the same way as the server Finished method, but with a couple small differences:</p>
<ul>
<li>The client handshake traffic secret is used as the key to the HMAC.</li>
<li>The context hash now has to include the Finished message sent by the server.</li>
</ul>
<p>If we re-run the script using the updated values, we get this hash:</p>
<pre><code class="hljs">13e0061c0160d048c9ea16964b12d5340630c8e30f04c48b895f98f898113d31b2c9653af573952ad5ead6719b34fc17</code></pre><p>which matches the expected value.</p>
</div>
</div>

<h1 id="s--c-new-session-ticket">S → C: New Session Ticket <a class="section-link" href="#s--c-new-session-ticket">&sect;</a></h1><p>TLS 1.3 supports a feature called session resumption to reduce the number of full key exchanges a client has to do. Here&#39;s how it works: after completing a handshake, the server may send the client a value called a <strong>session ticket</strong>. Next time, the client can present the session ticket to the server as a preshared key and pick up last time the two parties left off, instead of starting from scratch. Let&#39;s examine the parts of a session ticket.</p>
<p><em>Only the decrypted message is shown.</em></p>
<div class="server packet">
<div class="segment" data-hex="04000105" data-name="Handshake Header">

<ul>
<li><code>04</code>: message type (4 for NewSessionTicket)</li>
<li><code>00 01 05</code>: message length (261 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="00001c20" data-name="Lifetime">

<p>The lifetime of the ticket, in seconds. This ticket is valid for up to 7200 seconds after it is issued.</p>
</div>
<div class="segment" data-hex="5831c630" data-name="Age Add">

<p>This value is used to prevent eavesdroppers from learning the lifetime of the ticket when the client uses it (since it will be sent in plaintext). Clients should add this value to the lifetime to obfuscate the value in a way that only a server which knows the age_add value can figure out the true lifetime. </p>
<p>For example, if the client were to resume a session using this ticket, it would send <code>lifetime + age_add</code> to the server, which is <code>0x5831e250</code>. Without knowing <code>age_add</code>, it is <strong>impossible</strong> for an eavesdropper to determine <code>lifetime</code>.</p>
</div>
<div class="segment" data-hex="080000000000000000" data-name="Nonce">

<p>The nonce uniquely identifies a ticket.</p>
<ul>
<li><code>08</code>: data length (8 bytes)</li>
<li><code>00 00 00 ... 00 00 00</code>: the nonce</li>
</ul>
</div>
<div class="segment" data-hex="00f070add483a5ee6559224cd7e701399258d31c391336459ca6c8a84447a2a4e6303d9c8a288de2295289f9f965dcec95cb79a91c880f11264a4b52f44a3c98652d69123dbe15b8cb593ff08cfe96ef2d9c953a3d05062dc7c5c08584577638af4f84814420f20f127eb08572dff7dc19218b60e9e12711fd33d0b99014ab918f533389e712b729c4ca909f3cecf900eb2917dc4fd1a54317c36dbf2028d6311ba631949d620c232106a8ba667a86d88e77c33b9acf010c1e2ca52db64c05f72baef8de3990c4da13e5511e624ca169d90159477ce15e53edeadaa1f87ddb30761bc803f0ee73b42df790af729dc4955697" data-name="Ticket" data-preview-truncate="47">

<p>This part is the ticket itself. The value of the ticket has no defined structure; the server can put whatever it needs to keep track of clients in this field, hence why it is considered <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque</a>.</p>
</div>
<div class="segment" data-hex="0000" data-name="Extensions Length">

<p>Length of the extensions section (0 bytes).</p>
</div>
</div>

<p>Session tickets are single-use only, so upon initiating a new session some TLS implementations will send two tickets to give the client some added flexibility. The second session ticket is omitted since it is pretty much the same as the first one in structure.</p>
<h1 id="application-key-calculation">Application Key Calculation <a class="section-link" href="#application-key-calculation">&sect;</a></h1><p>From this point on, messages are encrypted by a new set of keys known as the <em>application traffic keys</em>. We can follow their derivation in the key schedule.</p>
<p>First, we generate the master secret.</p>
<pre><code class="hljs">derivedSecret2 = <span class="hljs-title function_">deriveSecret</span>(handshakeSecret, <span class="hljs-string">&quot;derived&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>));
masterSecret = <span class="hljs-title function_">hkdfExtract</span>(derivedSecret2, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-variable constant_">HASHLEN</span>));</code></pre><p>Next, the application secrets are derived. These values will be used by the client and server, respectively, to generate their encryption keys.</p>
<pre><code class="hljs">applicationContext = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([handshakeContext, <span class="hljs-title class_">EncryptedExtensions</span>, <span class="hljs-title class_">Certificate</span>, <span class="hljs-title class_">CertificateVerify</span>, <span class="hljs-title class_">ServerFinished</span>]);
clientApplicationTrafficSecret = <span class="hljs-title function_">deriveSecret</span>(masterSecret, <span class="hljs-string">&quot;c ap traffic&quot;</span>, applicationContext);
serverApplicationTrafficSecret = <span class="hljs-title function_">deriveSecret</span>(masterSecret, <span class="hljs-string">&quot;s ap traffic&quot;</span>, applicationContext);</code></pre><p>We can now derive a set of values that we can use with our cipher (AES-256), much like we did earlier during the handshake.</p>
<pre><code class="hljs">clientApplicationKey = <span class="hljs-title function_">hkdfExpandLabel</span>(clientApplicationTrafficSecret, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">32</span>);
clientApplicationIV = <span class="hljs-title function_">hkdfExpandLabel</span>(clientApplicationTrafficSecret, <span class="hljs-string">&quot;iv&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">12</span>);

serverApplicationKey = <span class="hljs-title function_">hkdfExpandLabel</span>(serverApplicationTrafficSecret, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">32</span>);
serverApplicationIV = <span class="hljs-title function_">hkdfExpandLabel</span>(serverApplicationTrafficSecret, <span class="hljs-string">&quot;iv&quot;</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>), <span class="hljs-number">12</span>);</code></pre><p>We are finally ready to read the last part of the session.</p>
<h1 id="s--c-application-data">S → C: Application Data <a class="section-link" href="#s--c-application-data">&sect;</a></h1><p>The script I wrote to generate this session finishes by sending four bytes of application data to the server. Let&#39;s see what&#39;s inside.</p>
<p>Here&#39;s the unencrypted packet:</p>
<div class="server packet">
<div class="segment" data-hex="1703030015" data-name="Record Header">

<ul>
<li><code>17</code>: record type (23 for Application Data)</li>
<li><code>03 03</code>: protocol version (TLS 1.2 for backwards compatibility)</li>
<li><code>00 15</code>: length of payload (21 bytes)</li>
</ul>
</div>
<div class="segment" data-hex="09666bb5a3" data-name="Ciphertext">

<p>The client&#39;s message to the server, encrypted.</p>
</div>
<div class="segment" data-hex="6067e79f614aac921bf3c5d86ba781ea" data-name="Authentication Tag">

<p>Used by the AEAD cipher to verify that the cipher text is intact.</p>
</div>
</div>

<p>Now, decrypted:</p>
<div class="server packet">
<div class="segment" data-hex="deadbeef" data-name="Data">

<p>The client cordially greets the server by sending the bytes <a href="https://en.wikipedia.org/wiki/Hexspeak">0xDEADBEEF</a>.</p>
</div>
<div class="segment" data-hex="17" data-name="Data Type">

<p>The actual data type of the record (23 for Application Data).</p>
</div>
</div>

<p>And, at long last, the client and server have a secure channel which they can communicate through.</p>
<h1 id="epilogue">Epilogue <a class="section-link" href="#epilogue">&sect;</a></h1><p>This article only shows part of what makes TLS tick. There&#39;s much more beneath the surface; things like 0-RTT messages, client authentication, SNI, ALPN, the list goes on. Not to mention the fact that TLS 1.3 is vastly different from TLS 1.2 in many ways&mdash;though I specifically chose TLS 1.3 since it is more elegant than TLS 1.2, which is more nuanced thanks to several well-known security holes. To learn more, the RFCs are your best friend. Skip ahead to the Further Reading section for some good references.</p>
<p>Oh, and if you liked this article, good news: there are <a href="internet-series.html">more like it</a> on my blog.</p>
<h1 id="behind-the-scenes">Behind the Scenes <a class="section-link" href="#behind-the-scenes">&sect;</a></h1><p>Making the interactive TLS session turned out to be surprisingly tricky. I ended up modifying OpenSSL to log the private keys used in the handshake key exchange process and rebuilding NodeJS from source. Here&#39;s the patch I applied before rebuilding:</p>
<pre><code class="hljs"><span class="hljs-comment">diff --git a/deps/openssl/openssl/ssl/statem/extensions_clnt.c b/deps/openssl/openssl/ssl/statem/extensions_clnt.c</span>
<span class="hljs-comment">index 7b46074232..bd765f43f0 100644</span>
<span class="hljs-comment">--- a/deps/openssl/openssl/ssl/statem/extensions_clnt.c</span>
<span class="hljs-comment">+++ b/deps/openssl/openssl/ssl/statem/extensions_clnt.c</span>
<span class="hljs-meta">@@ -613,6 +613,11 @@</span> static int add_key_share(SSL *s, WPACKET *pkt, unsigned int curve_id)
         }
     }
 
<span class="hljs-addition">+    /* print out the key like the sneaky devils we are */</span>
<span class="hljs-addition">+    BIO *bp = BIO_new_fp(stdout, BIO_NOCLOSE);</span>
<span class="hljs-addition">+    EVP_PKEY_print_private(bp, key_share_key, 1, NULL);</span>
<span class="hljs-addition">+    BIO_free(bp);</span>
<span class="hljs-addition">+</span>
     /* Encode the public key. */
     encodedlen = EVP_PKEY_get1_encoded_public_key(key_share_key,
                                                   &amp;encoded_point);
<span class="hljs-comment">diff --git a/deps/openssl/openssl/ssl/statem/extensions_srvr.c b/deps/openssl/openssl/ssl/statem/extensions_srvr.c</span>
<span class="hljs-comment">index 0b6e843e8a..757c49190c 100644</span>
<span class="hljs-comment">--- a/deps/openssl/openssl/ssl/statem/extensions_srvr.c</span>
<span class="hljs-comment">+++ b/deps/openssl/openssl/ssl/statem/extensions_srvr.c</span>
<span class="hljs-meta">@@ -1670,6 +1670,11 @@</span> EXT_RETURN tls_construct_stoc_key_share(SSL *s, WPACKET *pkt,
             return EXT_RETURN_FAIL;
         }
 
<span class="hljs-addition">+	/* more devilish key printing */</span>
<span class="hljs-addition">+	BIO *bp = BIO_new_fp(stdout, BIO_NOCLOSE);</span>
<span class="hljs-addition">+	EVP_PKEY_print_private(bp, skey, 1, NULL);</span>
<span class="hljs-addition">+	BIO_free(bp);</span>
<span class="hljs-addition">+</span>
         /* Generate encoding of server key */
         encoded_pt_len = EVP_PKEY_get1_encoded_public_key(skey, &amp;encodedPoint);
         if (encoded_pt_len == 0) {
</code></pre><p>Turns out, that was enough instrumentation to figure out all the other secrets used in the handshake. A couple weeks of banging my head on various RFCs was enough to piece together the rest of the puzzle. After that, it was a simple matter of using NodeJS to create a TLS client and server, then capturing the exchange using <code>tcpdump</code>. Here&#39;s the client/server code.</p>
<pre><code class="hljs"><span class="hljs-comment">// run with --tls-keylog=...</span>

<span class="hljs-keyword">const</span> tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;tls&quot;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-keyword">const</span> port = <span class="hljs-number">8443</span>, host = <span class="hljs-string">&quot;test.bithole.dev&quot;</span>;

<span class="hljs-keyword">const</span> server = tls.<span class="hljs-title function_">createServer</span>({
    <span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;fullchain.pem&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>),
    <span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;privkey.pem&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>)
});

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;secureConnection&quot;</span>, <span class="hljs-function"><span class="hljs-params">tlsSocket</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;connection&quot;</span>);
    tlsSocket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;data received:&quot;</span>, data));
});

server.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Started listening&quot;</span>));

<span class="hljs-keyword">const</span> secureSocket = tls.<span class="hljs-title function_">connect</span>({host, port});
secureSocket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;secureConnect&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;client connected&quot;</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> secureSocket.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0xde</span>,<span class="hljs-number">0xad</span>,<span class="hljs-number">0xbe</span>,<span class="hljs-number">0xef</span>])), <span class="hljs-number">1000</span>);
});</code></pre><p>I created a subdomain <code>test.bithole.dev</code> resolving to <code>127.0.0.1</code> and grabbed a certificate through Let&#39;s Encrypt to make this example a little more realistic.</p>
<p>You can download the full packet capture of the exchange which this page is based on <a href="resources/tls/capture.pcap">here</a>. You&#39;ll also need the <a href="resources/tls/keylog.txt">keylog</a> to decrypt the capture.</p>
<h1 id="further-reading">Further Reading <a class="section-link" href="#further-reading">&sect;</a></h1><ul>
<li><a href="https://tls13.ulfheim.net/">TLS 1.3 Illustrated</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8446">IETF - RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8448">IETF - RFC 8448: Example Handshake Traces for TLS 1.3</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5869">IETF - RFC 5869: HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5280">IETF - RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a></li>
<li><a href="https://developers.cloudflare.com/fundamentals/internet/protocols/tls">Cloudflare Fundamentals - TLS</a></li>
<li><a href="https://certificate.transparency.dev/howctworks/">Certificate Transparency - How CT Works</a></li>
<li><a href="https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/">Let&#39;s Encrypt - A Warm Welcome to ASN.1 and DER</a></li>
</ul>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="preferred-color-scheme"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>