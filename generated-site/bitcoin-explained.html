<!DOCTYPE html><html lang="en" class="serif"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Yet Another Bitcoin Explanation</title><meta property="og:title" content="Yet Another Bitcoin Explanation"><meta property="og:type" content="website"><meta property="og:description" content="Because why not?"><meta name="description" content="Because why not?"><link rel="stylesheet" href="static/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="stylesheet" href="static/stylesheets/main.css"><script>const loadSetting = name => {
    if(localStorage.getItem(name) === "true")
        document.documentElement.classList.add(name);
    else
        document.documentElement.classList.remove(name);
};

loadSetting("serif");
loadSetting("darkmode");</script><script defer src="static/scripts/ui.js"></script><link rel="icon" type="image/png" sizes="16x16" href="static/images/favicon.png"><link rel="canonical" href="https://blog.bithole.dev/bitcoin-explained.html"></head><body><header><a href="/"><img src="static/images/banner.jpg" alt="blog banner"></a></header><main><p id="date" class="date">January 23, 2022</p><h1 style="margin-top: 0">Yet Another Bitcoin Explanation</h1><nav><div id="contents"><p>Table of Contents</p><a href="#the-ledger"><p>The Ledger</p></a><a href="#digital-signatures"><p>Digital Signatures</p></a><a href="#unspent-transaction-outputs"><p>Unspent Transaction Outputs</p></a><a href="#double-spending-and-consensus"><p>Double Spending and Consensus</p></a><a href="#blockchain-and-proof-of-work"><p>Blockchain and Proof of Work</p></a><a href="#difficulty"><p>Difficulty</p></a><a href="#references"><p>References</p></a></div><button id="show-toc">&#9776; Contents</button></nav><p>There&#39;s a small chance you might have heard of this thing called <a href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin</a>. Well, the principles behind it are rather fascinating. Unfortunately, in the recent frenzy of hype around &quot;decentralization&quot; and (<em>retching</em>) Web3, it seems that nuanced discussion about how these decentralized systems actually work has been all but lost. So let&#39;s take a deep dive into the bowels of Bitcoin.</p>
<p>Before we begin, let&#39;s establish a baseline of how conventional payment systems work so that we can contrast it with how Bitcoin operates. The modern financial system has taken on a great deal of complexity over the ages, but a simplification will do for our purposes: a centralized organization, such as your bank, is responsible for keeping track of its clients&#39; account balances. When a transaction is made, the bank updates the balances of each party involved in the transaction. This system works very well from a functional standpoint, but such a system has two disadvantages:</p>
<ul>
<li><p>Your account is entirely controlled by whichever organization you choose to keep your money with.</p>
</li>
<li><p>All of your transactions must be tied to a real-world identity.</p>
</li>
</ul>
<p>These issues can be remedied by eliminating the central authority, but this raises an obvious problem: who keeps track of transactions, then? Bitcoin solves this by keeping a full record of all transactions (the <em>ledger</em>) on every node in the network.</p>
<h1 id="the-ledger">The Ledger <a class="section-link" href="#the-ledger">&sect;</a></h1><p>Suppose that I (Adrian) and three other friends&mdash;we&#39;ll call them Jayant, Akarsh, and Izaan&mdash;want to create a decentralized payment system. We come up with a simple scheme: whenever one of us makes a transaction, we will record it in our personal ledger and relay it to another member of the network, who will repeat this process until everyone has seen the transaction.</p>
<p>This works fine, initially; we can keep track of how much money each person has by finding the difference between how much money they&#39;ve received and how much money they&#39;ve sent. This way, transactions where a person attempts to spend more money than they actually have can be rejected. However, this scheme has some major problems.</p>
<p><strong>Transaction Authenticity</strong></p>
<p>Anyone can make a transaction as anybody else. For example, Jayant could fabricate a transaction where I send him all of my funds, and broadcast it to the network. This is obviously unacceptable, but it&#39;s actually easily solved with cryptography. </p>
<h2 id="digital-signatures">Digital Signatures <a class="section-link" href="#digital-signatures">&sect;</a></h2><figure style="max-width: 491px">
    <img src="resources/bitcoin/digital-signature.png" alt="illustration of a digital signature scheme">
    <figcaption>A diagram of a public-key digital signature scheme. <a href="https://en.wikipedia.org/wiki/File:Private_key_signing.svg">Image</a> by <a href="https://commons.wikimedia.org/wiki/User:FlippyFlink">FlippyFlink</a> / <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA</a></figcaption>
</figure>

<p>Thanks to the magic of cryptography, there are schemes which allow you to produce a digital signature which anyone can verify but no one can forge. Here&#39;s how it works:</p>
<ul>
<li><p>First, the signer generates a value known as a private key. An algorithm is used to derive the corresponding public key. The keypair has the property that you cannot determine the value of the private key from the value of the public key, so it is safe to distribute the public key.</p>
</li>
<li><p>To sign a message, the signer feeds the message and the private key into a signing algorithm, which produces a fixed-length digital signature. This signature can then be distributed alongside the message to prove its authenticity.</p>
</li>
<li><p>Anyone can input the message, the signature, and the signer&#39;s public key into a verification algorithm. The verification will fail if the message has been altered or the signature is not valid.</p>
</li>
</ul>
<p>Digital signatures can help us secure our transaction system against impersonation. We can switch to using public keys instead of names instead of identities. By requiring that each transaction contain a valid signature, we make it essentially impossible for someone to create transactions as someone else.</p>
<p>However, digital signatures do not fully solve our problems. For example, if I made a transaction sending Akarsh some money, while he&#39;s unable to create a transaction using my identity since he cannot forge the signature, he can simply rebroadcast the same transaction sending him money as many times as he&#39;d like, executing a <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attack</a>. We can fix this scheme by embracing the notion of unspent transaction outputs.</p>
<h2 id="unspent-transaction-outputs">Unspent Transaction Outputs <a class="section-link" href="#unspent-transaction-outputs">&sect;</a></h2><p>So far, we&#39;ve regarded our digital currency as only existing in abstract quantities. The truth is, Bitcoin handles things a little differently.</p>
<p>In the Bitcoin protocol, each transaction is an entity with inputs and outputs. Each input references the output of a previous transaction. By mandating that a given output can only be spent once, we prevent replay attacks from succeeding. This also simplifies transaction validation, since nodes can simply maintain a list of unspent transaction outputs (<a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXOs</a>) instead of going through every single transaction in the ledger.</p>
<p>Here&#39;s an example of how UTXOs work. Suppose Akarsh sends me 10 coins. He would use one of his UTXOs as the input to the transaction, which would have an output of 10 coins to my public key and another output back to Akarsh if the value of the input was not exactly equal to 10, kind of like change in a cash transaction. If I wanted to send 7 coins to Jayant, I would create a transaction with the output of the prior transaction as the input. The new transaction would have two outputs, one addressed to Jayant worth 7 coins, and one addressed to me worth 3 coins. </p>
<figure style="max-width: 793px">
    <img src="resources/bitcoin/utxo.png" alt="diagram of the previously described exchange">
    <figcaption>A visual representation of the exchange, totally not drawn in MS Paint. Note that this is a simplification; today, most transactions have multiple inputs and outputs.</figcaption>
</figure>

<p>This seemingly makes our currency watertight, but... how exactly do we keep nodes from trying to spend the same output several times? The way Bitcoin approaches this problem forms the foundation of blockchain technology. Let&#39;s dig in.</p>
<h1 id="double-spending-and-consensus">Double Spending and Consensus <a class="section-link" href="#double-spending-and-consensus">&sect;</a></h1><p>Double spending is a problem that most conventional payment systems don&#39;t have. For instance, it is physically impossible to double-spend cash; if I pay someone with a five-dollar note. I can&#39;t pay someone else with that note since I no longer have it after the transaction. But the Bitcoin network suffers from incomplete knowledge: because messages have to be relayed from node-to-node, the order which members of the network receive transactions can vary wildly. </p>
<p>This can easily be exploited in our current scheme. Suppose Jayant and Adrian both operate online businesses which accept our hypothetical cryptocurrency. Izaan could create two transactions, one to Adrian and one to Jayant, and send them both into the network at the same time. Nodes which receive his transaction to Adrian first will reject the one to Jayant, and nodes which receive his transaction to Jayant first will reject the one to Adrian. Essentially, there is disagreement about the order of transactions. Without resolving conflicts like this, the network cannot function.</p>
<p>One logical solution to this problem is to take a vote. All nodes will accept the most popular option, and the network will come to agreement about the state of the ledger. But how do we allocate these votes? A naive solution would be to assign each host (each IP address) one vote, but as explained in the Bitcoin whitepaper, this has obvious pitfalls:</p>
<blockquote>
<p>If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. </p>
</blockquote>
<p>The way Bitcoin gets around this problem is insanely clever (in my book), but it is also the #1 contributor to Bitcoin&#39;s inefficiency and high environmental impact. Here&#39;s how it works.</p>
<h1 id="blockchain-and-proof-of-work">Blockchain and Proof of Work <a class="section-link" href="#blockchain-and-proof-of-work">&sect;</a></h1><figure style="max-width: 1022px">
    <img src="resources/bitcoin/blockchain.png" alt="diagram of the blockchain from the bitcoin whitepaper">
    <figcaption>The blockchain, as depicted in the Bitcoin whitepaper, in all its unadulterated glory.</figcaption>
</figure>


<p>Now is probably a good time to drop the concept of the ledger and introduce the concept of the <a href="https://en.wikipedia.org/wiki/Blockchain">blockchain</a>. The two are very similar datastructures; ultimately, both serve as linear records of transactions. However, if the entire network had to come to an agreement over every single transaction, the overhead would be tremendous (especially since <em>most</em> transactions aren&#39;t double-spend attempts, so wasting time on synchronization is pointless). Thus, we aggregate transactions into <em>blocks</em>, each of which can contain hundreds of transactions.</p>
<p>During normal network operation, certain nodes in the network called <em>miners</em> listen for transactions and accumulate them into a block. </p>
<h1 id="difficulty">Difficulty <a class="section-link" href="#difficulty">&sect;</a></h1><h1 id="references">References <a class="section-link" href="#references">&sect;</a></h1><ul>
<li><a href="https://bitcoin.org/bitcoin.pdf">Satoshi Nakamoto - Bitcoin Whitepaper</a></li>
<li><a href="http://hhanh00.github.io/bitcoin-akka-tutorial/index.html">Bitcoin-Akka (full Bitcoin implementation in Scala with associated commentary)</a></li>
<li><a href="https://developer.bitcoin.org/devguide/index.html">Bitcoin.org Developer Documentation</a></li>
</ul>
<img id="img-view" style="display: none"><h1>Comments</h1><noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="github-light"></script></main><footer><p>&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></footer></body></html>