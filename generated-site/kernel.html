<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Reviving egg-kernel</title><meta property="og:title" content="Reviving egg-kernel"><meta property="og:type" content="website"><meta property="og:description" content="After over a year of hiatus, it is time to once again breathe some life into my x86 kernel project. Hopefully, this attempt will not prove to be dead on arrival."><meta name="description" content="After over a year of hiatus, it is time to once again breathe some life into my x86 kernel project. Hopefully, this attempt will not prove to be dead on arrival."><link rel="canonical" href="https://blog.bithole.dev/kernel.html"><link rel="stylesheet" href="static/stylesheets/main.css"><link rel="stylesheet" href="static/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"></head><body><a href="/"><img src="static/images/banner0.jpg" alt="blog banner"></a><p id="date" class="date">December 24, 2021</p><h1 style="margin-top: 0">Reviving egg-kernel</h1><p>It&#39;s that time of year again. Yes. After a 14-month drought of commits on my <a href="https://github.com/adrian154/egg-kernel/">operating system project</a>, I have decided to bring it back to life, this time armed with 2x as much undue optimism, programming knowledge, and (most importantly) free time.</p>
<p>I&#39;ve gone ahead and dumped what egg-kernel is currently capable of to serve as a sort of roadmap for future development.</p>
<p>egg-kernel starts when its bootsector is loaded. The bootsector loads the bootloader, which...</p>
<ul>
<li>enables the A20 line</li>
<li>retrieves a map of available memory using the BIOS</li>
<li>loads the kernel into memory</li>
<li>sets up a basic flat memory model using the GDT</li>
<li>enters protected mode</li>
<li>launches the kernel</li>
</ul>
<p>The kernel itself doesn&#39;t do anything that you&#39;d expect an actual OS to do. (Yet.) It&#39;s mostly more x86 housekeeping:</p>
<ul>
<li>set up a GDT (again) and IDT </li>
<li>install exception handlers</li>
<li>remap the PIC and abstract away some of the more gory details of IRQ handling</li>
<li>enable paging</li>
<li>enter usermode and immediately raise a GPF for shits and giggles</li>
</ul>
<p>egg-kernel is the third iteration of my OS development journey. This time, I think I have accumulated enough knowledge to actually take it further. Regardless, I&#39;m not 100% satisfied with the codebase; there&#39;s a lot of poor design decisions (evidence of my rather bad understanding of C), and probably a healthy dose of undefined behaviors sprinkled in. Also, regrettably enough, I wrote most of egg-kernel during the height of my infatuation with CamelCase, leaving me forever beholden to my past foolishness.</p>
<p>Here is my loosely structured TODO list for the kernel.</p>
<ul>
<li>Implement a basic stream interface, so that logging can be handled with stdout/stdin. (this way logging via serial ports can also be seamlessly integrated)</li>
<li>Flesh out memory management<ul>
<li>Implement a better physical memory allocator<ul>
<li>The current allocator is rather inelegant. Page availability is tracked through a giant bitmap, which comes with the disadvantage of O(N) allocations. Maybe a stack or buddy-based scheme would be faster.</li>
</ul>
</li>
<li>Recursively map page tables</li>
<li>Make sure all the TLB-handling code works</li>
<li>Implement a virtual address allocator<ul>
<li>Implement a kernel heap so we can stop allocating everything statically.</li>
</ul>
</li>
<li>(Maybe) switch to a higher-half kernel, since this seems to be recommended as a Good Thing&trade;<ul>
<li>Why exactly is it better?</li>
<li>Gripe: this means paging might have to be set up in the bootloader, which is rather ugly.</li>
</ul>
</li>
</ul>
</li>
<li>Work towards usermode and multitasking<ul>
<li>Figure out the TSS</li>
<li>Implement software context switches</li>
<li>Implement a scheduler<ul>
<li>Create an abstract interface for PIT/HPET/other timing interrupt sources</li>
</ul>
</li>
<li>Make some syscalls<ul>
<li>Write a userspace libc</li>
</ul>
</li>
<li>Parse object file format instead of using flat binaries</li>
</ul>
</li>
<li>Transition to an actual filesystem<ul>
<li>Implement fs-reading code in bootsector/bootloader</li>
<li>Update build process accordingly</li>
<li>Write some ATA code for protected mode disk IO</li>
<li>Which filesystem?<ul>
<li>exFAT seems reasonably modern but also not super complicated</li>
</ul>
</li>
</ul>
</li>
<li>Far-future food for thought<ul>
<li>Support for SMP</li>
<li>Support for long mode</li>
<li>Use APIC instead of 8529 PICs<ul>
<li>What about MSI?</li>
</ul>
</li>
<li>Mess around with vm86</li>
<li>Mess around with ACPI</li>
<li>Mess around with PCI/virtio</li>
<li>Try running the OS on some real hardware</li>
</ul>
</li>
</ul>
<p>Later down the road I plan on writing some follow-up posts detailing my development journey on this blog. That is, if I ever get around to it.</p>
<noscript><b>Please enable Javascript to view comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="github-light"></script><p class="footnote">&copy; 2022 Adrian Zhang &bull; <a href="https://bithole.dev/">homepage</a> &bull; <a href="rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">contribute</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></body></html>