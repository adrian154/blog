<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>What's in a JPEG?</title><meta property="og:title" content="What's in a JPEG?"><meta property="og:type" content="website"><meta property="og:description" content="They say picture is worth a thousand words, so I took it upon myself to write a thousand words about a picture. Today, we examine the remarkable technology behind the humble JPEG format."><meta name="description" content="They say picture is worth a thousand words, so I took it upon myself to write a thousand words about a picture. Today, we examine the remarkable technology behind the humble JPEG format."><link rel="canonical" href="https://blog.bithole.dev/jpeg.html"><link rel="stylesheet" href="static/stylesheets/main.css"><link rel="stylesheet" href="static/stylesheets/highlight-style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><link rel="icon" type="image/png" sizes="16x16" href="static/images/favicon.png"><link rel="stylesheet" href="static/stylesheets/jpeg.css"><script defer src="static/scripts/jpeg.js"></script></head><body><a href="/"><img src="static/images/banner1.jpg" alt="blog banner"></a><p id="date" class="date">December 31, 1969</p><h1 style="margin-top: 0">What's in a JPEG?</h1><p>Recently, I set out to create my own photo organizer, a project which eventually bloomed into <a href="https://github.com/adrian154/photobox">Photobox</a>. In doing so, I came across a great deal of mucking about with image formats and compression, and then it dawned on me: JPEGs are ridiculously good at compressing image data, far beyond what seems possible! Take this picture, for example:</p>
<p><a href="resources/jpeg/test-compressed.jpg" target="_blank"><img src="resources/jpeg/test-compressed.jpg" alt="a test image"></a></p>
<p><em>This poor cormorant has no idea what he&#39;s about to go through.</em></p>
<p>This image is 597 by 800 pixels. Each pixel consists of three components, red, green, and blue. The brightness of each component is encoded as an 8-bit value, where 0 is no light emitted and 2^8 - 1 = 255 is the maximum brithness your display can muster. So, each pixel contains at least three bytes of information. Multiply that by the number of pixels, and we get a file size of around 359 kilobytes! Yet the image shown above is actually only 43kB in size, just 12% of the value we just calculated. In other words, by encoding the image using the JPEG format, we can achieve a compression ratio of roughly 8:1. Part of this is because JPEG is <strong>lossy</strong>, meaning the compressed image is slightly degraded compared to the original image, but in most situations this loss in quality is virtually imperceptible. How is this possible? Let&#39;s find out.</p>
<h1 id="chroma-subsampling">Chroma Subsampling <a class="section-link" href="#chroma-subsampling">&sect;</a></h1><p>The first method that JPEG uses to reduce the filesize is a technique called <strong>chroma subsampling</strong>. Essentially, this step exploits the fact that our eyes are much more sensitive to changes in brightness than to changes in color. After all, changes in brightness are how we perceive shapes and features. If you converted an image to black and white, you would still have a good idea of what the image is a picture of, whereas if you only had the color information it&#39;d convey much less detail. If we stored the color information at a lower resolution than the brightness information, it could reduce the size of the image without noticeably degrading the quality.</p>
<p>RGB isn&#39;t very conducive to chroma subsampling, though, because the brightness of the pixel is baked into all three channels. JPEG first converts the RGB pixel data to a color space called <a href="https://en.wikipedia.org/wiki/YCbCr">YCbCr</a>. Like RGB, YCbCr pixels also consist of three values; however, the meaning of the values are different. <strong>Y</strong> is the luminance (brightness) of the pixel, and <strong>Cb</strong> and <strong>Cr</strong> together represent the color of the pixel without any luminance info.</p>
<p>But how is RGB mapped to YCbCr? In my opinion, the relationship between the two color spaces is best explained visually. We can imagine RGB as a cube, with <em>x</em>-axis as red, <em>y</em>-axis as green, and <em>z</em>-axis as blue.</p>
<p><video class="center" loop controls autoplay><source src="resources/jpeg/rgb-cube-animation.mp4" type="video/mp4"></video></p>
<p>This cube has one important property: there exists a line through the cube where the R, G, and B values are all equal. We can treat the luminance component (Y) as representing distance along this axis. Now, for a given Y, we can take a slice of the cube and assign the remaining two degrees of freedom to Cb and Cr, respectively.</p>
<p>This is essentially how YCbCr works, except the RGB values are first processed so that the cube ends up looking more like a slanted rectangular prism. For the more math-inclined readers, you might recognize this as an affine transformation, hence why the RGB-YCbCr conversion is generally described using matrix multiplication. This variation is necessary to ensure that all the &quot;slices&quot; are rectangular. Here&#39;s a demo that shows the Cb/Cr planes as we adjust Y. </p>
<p><video class="center" loop controls autoplay><source src="resources/jpeg/ycbcr-slices.mp4" type="video/mp4"></video></p>
<p><em>No, that Y is definitely not backwards.</em></p>
<p>Here&#39;s what the CbCr plane looks like at Y=0.5:</p>
<p><a href="resources/jpeg/ycbcr.png" target="_blank"><img src="resources/jpeg/ycbcr.png" alt="ycbcr diagram"></a></p>
<p>When an image is converted to JPEG, the first thing that happens is that the RGB colors are converted to YCbCr. The Cb and Cr channels are stored at half the resolution of the full image.</p>
<p>Let&#39;s compare what the components of the image look like in the two color spaces. Here&#39;s what the image looks like in RGB.</p>
<p><a href="resources/jpeg/rgb-components.jpg" target="_blank"><img src="resources/jpeg/rgb-components.jpg" alt="rgb components of the image"></a></p>
<p>And here&#39;s what the image looks like in YCbCr:</p>
<p><a href="resources/jpeg/cormorant-ycbcr.jpg" target="_blank"><img src="resources/jpeg/cormorant-ycbcr.jpg" alt="image in ycbcr color space"></a></p>
<p>Note that unlike the RGB components, you can&#39;t just add Y, Cb, and Cr together and expect it to look like the original imgae.</p>
<noscript><b>Please enable Javascript to view the comments on this post.</b></noscript><script src="https://utteranc.es/client.js" crossorigin="anonymous" repo="adrian154/blog" issue-term="title" label="blog-post-comments" theme="github-light"></script><p class="footnote">&copy; 2022 <a href="https://bithole.dev/">Adrian Zhang</a> &bull; <a href="rss.xml">rss</a> &bull; <a href="https://github.com/adrian154/blog">source</a> &bull; <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a></p></body></html>